[{"id":"\bentasis","title":"Entasis","description":"가상자산 거래소 개발","content":"<h2>시스템 개요</h2>\n<p>전자고지 시스템은 기업이나 기관에서 발행하는 각종 고지서를 카카오, 네이버, KT 등의 플랫폼을 통해 전자문서로 발송하고 관리하는 통합 솔루션입니다.</p>\n<h3>주요 기능</h3>\n<ol>\n<li><strong>전자고지서 발송 관리</strong>\n<ul>\n<li>대상자 그룹 관리</li>\n<li>발송 이력 추적</li>\n<li>멀티 플랫폼 발송 설정</li>\n<li>발송 상태 모니터링</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"/images/mobyn/mobyn_document_payment.gif\" alt=\"3\">\n<em>결제 정보 관리 및 처리</em></p>\n<ol start=\"2\">\n<li><strong>결제 시스템 연동</strong>\n<ul>\n<li>NICEpay 결제 모듈 통합</li>\n<li>실시간 결제 상태 확인</li>\n<li>결제 이력 관리</li>\n<li>환불 프로세스 지원</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"/images/mobyn/mobyn_stats_1.gif\" alt=\"5\">\n<em>일별/월별 발송량 통계 분석</em></p>\n<p><img src=\"/images/mobyn/mobyn_stats_2.gif\" alt=\"6\">\n<em>플랫폼별 발송 성공률 분석</em></p>\n<p><img src=\"/images/mobyn/mobyn_stats_3.gif\" alt=\"7\">\n<em>결제 전환율 및 매출 분석</em></p>\n<p><img src=\"/images/mobyn/mobyn_stats_4.gif\" alt=\"8\">\n<em>기간별 상세 통계 리포트</em></p>\n<ol start=\"3\">\n<li><strong>통계 대시보드</strong>\n<ul>\n<li>발송 현황 분석</li>\n<li>플랫폼별 성공률 추적</li>\n<li>결제 전환율 모니터링</li>\n<li>기간별 통계 리포트</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"/images/mobyn/mobyn_document_management.gif\" alt=\"2\">\n<em>문서 템플릿 관리 및 편집</em></p>\n<ol start=\"4\">\n<li><strong>발송 관리 시스템</strong>\n<ul>\n<li>대상자 그룹 관리</li>\n<li>발송 이력 추적</li>\n<li>멀티 플랫폼 발송 설정</li>\n<li>발송 상태 모니터링</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"/images/mobyn/mobyn_status.gif\" alt=\"9\">\n<em>실시간 발송 상태 모니터링</em></p>\n<ol start=\"5\">\n<li><strong>발송 제목 및 내용 관리</strong>\n<ul>\n<li>발송 제목 및 내용 관리</li>\n<li>대상자 그룹 관리</li>\n<li>발송 이력 추적</li>\n<li>멀티 플랫폼 발송 설정</li>\n<li>발송 상태 모니터링</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"/images/mobyn/mobyn_subject.gif\" alt=\"10\">\n<em>발송 제목 및 내용 관리</em></p>\n<ol start=\"6\">\n<li><strong>발송 대상자 관리</strong>\n<ul>\n<li>대상자 그룹 관리</li>\n<li>발송 이력 추적</li>\n<li>멀티 플랫폼 발송 설정</li>\n<li>발송 상태 모니터링</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"/images/mobyn/mobyn_send.gif\" alt=\"4\">\n<em>대량 발송 프로세스 실행</em></p>\n<ol start=\"7\">\n<li><strong>발송 예약 관리</strong>\n<ul>\n<li>발송 예약 관리</li>\n<li>발송 이력 추적</li>\n<li>멀티 플랫폼 발송 설정</li>\n<li>발송 상태 모니터링</li>\n</ul>\n</li>\n</ol>\n","plainContent":"\n## 시스템 개요\n\n전자고지 시스템은 기업이나 기관에서 발행하는 각종 고지서를 카카오, 네이버, KT 등의 플랫폼을 통해 전자문서로 발송하고 관리하는 통합 솔루션입니다.\n\n### 주요 기능\n\n1. **전자고지서 발송 관리**\n   - 대상자 그룹 관리\n   - 발송 이력 추적\n   - 멀티 플랫폼 발송 설정\n   - 발송 상태 모니터링\n\n![3](/images/mobyn/mobyn_document_payment.gif)\n_결제 정보 관리 및 처리_\n\n2. **결제 시스템 연동**\n   - NICEpay 결제 모듈 통합\n   - 실시간 결제 상태 확인\n   - 결제 이력 관리\n   - 환불 프로세스 지원\n\n![5](/images/mobyn/mobyn_stats_1.gif)\n_일별/월별 발송량 통계 분석_\n\n![6](/images/mobyn/mobyn_stats_2.gif)\n_플랫폼별 발송 성공률 분석_\n\n![7](/images/mobyn/mobyn_stats_3.gif)\n_결제 전환율 및 매출 분석_\n\n![8](/images/mobyn/mobyn_stats_4.gif)\n_기간별 상세 통계 리포트_\n\n3. **통계 대시보드**\n   - 발송 현황 분석\n   - 플랫폼별 성공률 추적\n   - 결제 전환율 모니터링\n   - 기간별 통계 리포트\n\n![2](/images/mobyn/mobyn_document_management.gif)\n_문서 템플릿 관리 및 편집_\n\n4. **발송 관리 시스템**\n   - 대상자 그룹 관리\n   - 발송 이력 추적\n   - 멀티 플랫폼 발송 설정\n   - 발송 상태 모니터링\n\n![9](/images/mobyn/mobyn_status.gif)\n_실시간 발송 상태 모니터링_\n\n5. **발송 제목 및 내용 관리**\n   - 발송 제목 및 내용 관리\n   - 대상자 그룹 관리\n   - 발송 이력 추적\n   - 멀티 플랫폼 발송 설정\n   - 발송 상태 모니터링\n\n![10](/images/mobyn/mobyn_subject.gif)\n_발송 제목 및 내용 관리_\n\n6. **발송 대상자 관리**\n   - 대상자 그룹 관리\n   - 발송 이력 추적\n   - 멀티 플랫폼 발송 설정\n   - 발송 상태 모니터링\n\n![4](/images/mobyn/mobyn_send.gif)\n_대량 발송 프로세스 실행_\n\n7. **발송 예약 관리**\n   - 발송 예약 관리\n   - 발송 이력 추적\n   - 멀티 플랫폼 발송 설정\n   - 발송 상태 모니터링\n","category":"projects","date":"2024-03-20","tags":["React","NicePay","TypeScript","React Hook Form"],"thumbnail":"/images/mobyn/mobyn_dashboard.gif"},{"id":"about-me","title":"개발자 윤수빈입니다.","description":"Hello! 👋 I am a Full Stack Engineer specialized in Financial Engineering and Data Processing.","content":"<h2>About Me</h2>\n<p>금융공학과 데이터 처리에 특화된 풀스택 엔지니어입니다. Next.js, Python, Java를 활용하여 대규모 데이터 처리 및 금융 시스템을 구축하며, 알고리즘 최적화와 안정적인 웹 솔루션 개발에 중점을 두고 있습니다.</p>\n<p>다양한 프로젝트 경험을 통해 복잡한 데이터 구조를 효율적으로 처리하고, 금융 모델을 실시간으로 구현하는 데 강점을 가지고 있습니다. 금융 플랫폼 개발에 있어 혁신적인 접근을 추구하며, 확장성 있는 웹 애플리케이션과 데이터를 활용한 전략적 시스템 구축을 통해 비즈니스 가치를 창출하고자 합니다.</p>\n<h2>Contact</h2>\n<ul>\n<li><strong>Location</strong>: Busan, South Korea</li>\n<li><strong>E-mail</strong>: yunsubin481@gmail.com</li>\n<li><strong>Notion</strong>: <a href=\"https://binsspace.notion.site/Bin-s-Space\">Bin's Space</a></li>\n</ul>\n<h2>Research &#x26; Studies</h2>\n<ul>\n<li><strong>금융공학</strong>: 투자론, 거시경제, 회계 연구</li>\n<li><strong>컴퓨터 과학</strong>: 자료구조, 네트워크, 데이터베이스, AI 연구</li>\n<li><strong>블록체인</strong>: STO 기반 증권형 토큰 거래소, NFT 거래소 프로젝트 연구</li>\n</ul>\n<h2>Education</h2>\n<ul>\n<li><strong>2018 - 2019</strong>: Bachelor of Business (독학학위제)\n<ul>\n<li>금융공학, 투자론, 거시경제, 회계 전공</li>\n</ul>\n</li>\n<li><strong>2019 - 2024</strong>: Bachelor of Computer Science (독학학위제)\n<ul>\n<li>자료구조, 네트워크, 데이터베이스, AI 전공</li>\n</ul>\n</li>\n<li><strong>2022 - 2023</strong>: BootCamp BlockChain (CodeStates)\n<ul>\n<li>STO, NFT, DeFi 플랫폼 개발 과정 수료</li>\n</ul>\n</li>\n</ul>\n<h2>Experience</h2>\n<h3>VISIONTEC (FullStack Developer)</h3>\n<p><strong>2024-05 ~ 2025-01</strong></p>\n<ul>\n<li>삼성화재, 한양대학교 데이터 관리 시스템 총괄</li>\n<li>실시간 데이터 처리 속도 최적화 (800건/초 → 25,000건/초)</li>\n<li>대규모 로그 데이터 분석 및 시각화 시스템 구축</li>\n<li>Next.js, PostgreSQL, Prisma, Docker, ChakraUI</li>\n<li>기획 및 디자인 포함 기여도 100%</li>\n</ul>\n<p><strong>2024-01 ~ 2024-05</strong></p>\n<ul>\n<li>금융 ERP 시스템 마이그레이션</li>\n<li>레거시 시스템을 React와 Flask 기반으로 현대화</li>\n<li>실시간 금융 데이터 처리 및 성능 최적화</li>\n<li>React, ChakraUI, Python Flask, MariaDB</li>\n<li>기여도 35%</li>\n</ul>\n<h3>IDINO (FullStack Developer)</h3>\n<p><strong>2024-05 ~ 현재</strong></p>\n<ul>\n<li>학사행정 시스템 개발</li>\n<li>마산대학교, 강원대학교, 여주대학교 장학생 관리 시스템 개발</li>\n<li>기업 협업 및 자문 결재 시스템 개발</li>\n<li>교원 평가 관리 및 학생 평가 관리 시스템 구축</li>\n<li>JAVA JSP, WebSquare, MySQL</li>\n<li>기여도 35%</li>\n</ul>\n<h3>KT, NAVER, KAKAO 연동 (Frontend Developer)</h3>\n<p><strong>2023-09 ~ 2024-01</strong></p>\n<ul>\n<li>문자 대량 발송 상담 챗봇 관리 시스템 개발</li>\n<li>Redux를 이용한 사용자 데이터 및 권한 관리 기능 구현</li>\n<li>KT API를 통한 대량 문자 발송 기능 구현</li>\n<li>카카오톡 알림톡 대량 발송 기능 구현</li>\n<li>챗봇 시나리오 및 템플릿 관리 기능 구현</li>\n<li>기여도 90%</li>\n</ul>\n<h3>NICEpay, 반응형 웹 (Frontend Developer)</h3>\n<p><strong>2023-04 ~ 2023-09</strong></p>\n<ul>\n<li>전자문서 및 전자고지 발송 기능 개발</li>\n<li>NICEpay 결제 기능 연동</li>\n<li>통계 페이지 및 반응형 웹 기능 개발</li>\n</ul>\n<p><img src=\"/images/profile3.jpg\" alt=\"Profile Image 3\"></p>\n<h2>Core Competencies</h2>\n<h3>금융 시스템 개발 전문성</h3>\n<p>복잡한 금융 모델을 실시간으로 처리하고 시각화하는 시스템 개발에 전문성을 보유하고 있습니다.\n대규모 데이터 처리 시스템 구축 경험을 통해, 금융 시장의 빠른 변화에 대응할 수 있는 확장성 있는 솔루션을 제공합니다.</p>\n<h3>지속적인 학습과 혁신</h3>\n<p>금융 시장과 기술의 빠른 변화에 대응하기 위해 끊임없이 새로운 것을 학습하고 있습니다.\n독학으로 금융공학과 컴퓨터 과학을 습득했으며, 블록체인과 같은 최신 기술을 금융 시스템에 접목시키는 시도를 지속하고 있습니다.</p>\n<h3>문제 해결 능력</h3>\n<p>복잡한 금융 데이터 처리 문제를 분석하고 효과적인 해결책을 찾아내는 과정에서 큰 성과를 이루어냈습니다.\n삼성화재와 한양대학교 프로젝트에서 데이터 처리 속도를 획기적으로 향상시킨 경험은 문제 해결에 대한 자신감을 더해주었습니다.</p>\n<h3>건강한 신체 관리</h3>\n<p>지속적인 성과 창출을 위해 체력 관리를 중요하게 생각합니다.\n주 5회, 하루 1시간 30분의 꾸준한 운동을 통해 업무 효율성과 집중력을 유지하고 있습니다.</p>\n","plainContent":"\n## About Me\n\n금융공학과 데이터 처리에 특화된 풀스택 엔지니어입니다. Next.js, Python, Java를 활용하여 대규모 데이터 처리 및 금융 시스템을 구축하며, 알고리즘 최적화와 안정적인 웹 솔루션 개발에 중점을 두고 있습니다.\n\n다양한 프로젝트 경험을 통해 복잡한 데이터 구조를 효율적으로 처리하고, 금융 모델을 실시간으로 구현하는 데 강점을 가지고 있습니다. 금융 플랫폼 개발에 있어 혁신적인 접근을 추구하며, 확장성 있는 웹 애플리케이션과 데이터를 활용한 전략적 시스템 구축을 통해 비즈니스 가치를 창출하고자 합니다.\n\n## Contact\n\n- **Location**: Busan, South Korea\n- **E-mail**: yunsubin481@gmail.com\n- **Notion**: [Bin's Space](https://binsspace.notion.site/Bin-s-Space)\n\n## Research & Studies\n\n- **금융공학**: 투자론, 거시경제, 회계 연구\n- **컴퓨터 과학**: 자료구조, 네트워크, 데이터베이스, AI 연구\n- **블록체인**: STO 기반 증권형 토큰 거래소, NFT 거래소 프로젝트 연구\n\n## Education\n\n- **2018 - 2019**: Bachelor of Business (독학학위제)\n  - 금융공학, 투자론, 거시경제, 회계 전공\n- **2019 - 2024**: Bachelor of Computer Science (독학학위제)\n  - 자료구조, 네트워크, 데이터베이스, AI 전공\n- **2022 - 2023**: BootCamp BlockChain (CodeStates)\n  - STO, NFT, DeFi 플랫폼 개발 과정 수료\n\n## Experience\n\n### VISIONTEC (FullStack Developer)\n\n**2024-05 ~ 2025-01**\n\n- 삼성화재, 한양대학교 데이터 관리 시스템 총괄\n- 실시간 데이터 처리 속도 최적화 (800건/초 → 25,000건/초)\n- 대규모 로그 데이터 분석 및 시각화 시스템 구축\n- Next.js, PostgreSQL, Prisma, Docker, ChakraUI\n- 기획 및 디자인 포함 기여도 100%\n\n**2024-01 ~ 2024-05**\n\n- 금융 ERP 시스템 마이그레이션\n- 레거시 시스템을 React와 Flask 기반으로 현대화\n- 실시간 금융 데이터 처리 및 성능 최적화\n- React, ChakraUI, Python Flask, MariaDB\n- 기여도 35%\n\n### IDINO (FullStack Developer)\n\n**2024-05 ~ 현재**\n\n- 학사행정 시스템 개발\n- 마산대학교, 강원대학교, 여주대학교 장학생 관리 시스템 개발\n- 기업 협업 및 자문 결재 시스템 개발\n- 교원 평가 관리 및 학생 평가 관리 시스템 구축\n- JAVA JSP, WebSquare, MySQL\n- 기여도 35%\n\n### KT, NAVER, KAKAO 연동 (Frontend Developer)\n\n**2023-09 ~ 2024-01**\n\n- 문자 대량 발송 상담 챗봇 관리 시스템 개발\n- Redux를 이용한 사용자 데이터 및 권한 관리 기능 구현\n- KT API를 통한 대량 문자 발송 기능 구현\n- 카카오톡 알림톡 대량 발송 기능 구현\n- 챗봇 시나리오 및 템플릿 관리 기능 구현\n- 기여도 90%\n\n### NICEpay, 반응형 웹 (Frontend Developer)\n\n**2023-04 ~ 2023-09**\n\n- 전자문서 및 전자고지 발송 기능 개발\n- NICEpay 결제 기능 연동\n- 통계 페이지 및 반응형 웹 기능 개발\n\n![Profile Image 3](/images/profile3.jpg)\n\n## Core Competencies\n\n### 금융 시스템 개발 전문성\n\n복잡한 금융 모델을 실시간으로 처리하고 시각화하는 시스템 개발에 전문성을 보유하고 있습니다.\n대규모 데이터 처리 시스템 구축 경험을 통해, 금융 시장의 빠른 변화에 대응할 수 있는 확장성 있는 솔루션을 제공합니다.\n\n### 지속적인 학습과 혁신\n\n금융 시장과 기술의 빠른 변화에 대응하기 위해 끊임없이 새로운 것을 학습하고 있습니다.\n독학으로 금융공학과 컴퓨터 과학을 습득했으며, 블록체인과 같은 최신 기술을 금융 시스템에 접목시키는 시도를 지속하고 있습니다.\n\n### 문제 해결 능력\n\n복잡한 금융 데이터 처리 문제를 분석하고 효과적인 해결책을 찾아내는 과정에서 큰 성과를 이루어냈습니다.\n삼성화재와 한양대학교 프로젝트에서 데이터 처리 속도를 획기적으로 향상시킨 경험은 문제 해결에 대한 자신감을 더해주었습니다.\n\n### 건강한 신체 관리\n\n지속적인 성과 창출을 위해 체력 관리를 중요하게 생각합니다.\n주 5회, 하루 1시간 30분의 꾸준한 운동을 통해 업무 효율성과 집중력을 유지하고 있습니다.\n","category":"about","date":"2024-03-20","tags":["Full Stack","Next.js","Python","Financial"],"thumbnail":"/images/profile1.jpg"},{"id":"convention_document","title":"Convention Document","description":"개발 규칙","content":"<h2>1. 목적</h2>\n<ol>\n<li>개발 표준화: 프론트엔드 개발에 일관성을 부여하여 코드의 가독성과 유지보수성을 높입니다.</li>\n<li>팀 협업 강화: 개발자들 간의 협업을 원활하게 하고 의사소통을 개선합니다.</li>\n<li>새로운 개발자 온보딩: 새로 합류한 개발자가 프로젝트에 빠르게 적응하고 효율적으로 개발할 수 있도록 돕습니다.</li>\n<li>코드 품질 향상: 일관된 코딩 스타일과 최적화 기법을 적용하여 코드의 품질을 향상시킵니다.</li>\n<li>유지보수성 강화: 일관된 구조와 명명 규칙을 통해 코드의 가독성을 높이고 유지보수를 용이하게 합니다.</li>\n</ol>\n<h2>2. 코딩 스타일 가이드</h2>\n<h3>2.1. 들여쓰기</h3>\n<ol>\n<li>Prettier의 기본설정으로 들여쓰기 합니다.</li>\n</ol>\n<h3>2.2. 변수와 상수</h3>\n<p>변수와 상수는 프론트엔드 개발에서 중요한 개념입니다. 이 섹션에서는 변수와 상수의 사용에 대한 가이드라인을 설명합니다.</p>\n<ol>\n<li>변수명과 상수명\n<ul>\n<li>변수명과 상수명은 의미를 명확하게 전달할 수 있도록 짓는 것이 좋습니다.</li>\n<li>변수명과 상수명은 영문을 사용하여 작성합니다.</li>\n<li>여러 단어로 이루어진 경우에는 단어 사이를 카멜케이스로 구분합니다. 예: myVariable, userName</li>\n</ul>\n</li>\n<li>변수의 선언과 할당\n<ul>\n<li>변수를 선언할 때에는 let 키워드를 사용합니다. 예: let count = 0;</li>\n<li>변수의 값은 필요에 따라 언제든지 변경할 수 있습니다.</li>\n</ul>\n</li>\n<li>상수의 선언과 할당\n<ul>\n<li>상수를 선언할 때에는 const 키워드를 사용합니다. 예: const PI = 3.14;</li>\n<li>상수는 한 번 할당된 값은 변경할 수 없습니다.</li>\n</ul>\n</li>\n<li>변수와 상수의 초기화\n<ul>\n<li>변수와 상수는 선언과 동시에 초기값을 할당하는 것이 좋습니다.</li>\n<li>초기화되지 않은 변수나 상수는 의도치 않은 동작을 야기할 수 있으므로 주의해야 합니다.</li>\n</ul>\n</li>\n</ol>\n<p>변수와 상수는 프로그램의 데이터를 저장하고 조작하는 데에 필수적인 요소입니다. 적절하게 변수와 상수를 활용하여 가독성 높은 코드를 작성하고, 필요에 따라 값의 변경 여부를 고려하여 변수와 상수를 선택하시기 바랍니다.</p>\n<h3>2.3. 함수와 메서드</h3>\n<p>함수와 메서드는 프론트엔드 개발에서 코드의 재사용성과 모듈화를 위해 중요한 요소입니다. 이 섹션에서는 함수와 메서드의 사용에 대한 가이드라인을 제시합니다.</p>\n<ol>\n<li>함수와 메서드의 정의\n<ul>\n<li>함수는 독립적으로 동작하는 코드 블록입니다. 주어진 입력을 받아서 처리하고, 결과를 반환할 수 있습니다.</li>\n<li>메서드는 객체에 속해 있는 함수로, 객체의 상태를 조작하거나 객체의 동작을 수행합니다.</li>\n</ul>\n</li>\n<li>함수와 메서드의 명명 규칙\n<ul>\n<li>함수와 메서드의 이름은 동사 형태로 짓는 것이 일반적입니다. 예: calculateTotal, loginUser</li>\n<li>함수와 메서드의 이름은 의미를 명확하게 전달할 수 있도록 작성해야 합니다.</li>\n<li>여러 단어로 이루어진 경우에는 카멜 케이스(camelCase)를 사용하여 작성합니다. 예: calculateTaxAmount, loginUserWithCredentials</li>\n</ul>\n</li>\n<li>함수와 메서드의 매개변수\n<ul>\n<li>함수와 메서드는 필요한 입력값을 매개변수(parameter)로 받을 수 있습니다.</li>\n<li>매개변수의 이름은 변수와 동일한 명명 규칙을 따르며, 입력값의 의미를 잘 표현할 수 있도록 작성해야 합니다.</li>\n</ul>\n</li>\n<li>함수와 메서드의 반환값\n<ul>\n<li>함수와 메서드는 필요에 따라 결과값을 반환할 수 있습니다.</li>\n<li>반환값의 타입은 명확하게 정의하고, 함수 또는 메서드의 목적과 일치하는 데이터를 반환해야 합니다.</li>\n</ul>\n</li>\n<li>함수와 메서드의 범위\n<ul>\n<li>함수와 메서드는 선언된 블록(scope) 내에서 유효합니다. 함수 내부에서 선언된 변수는 함수 내에서만 사용할 수 있으며, 함수 외부에서는 접근할 수 없습니다.</li>\n</ul>\n</li>\n</ol>\n<p>함수와 메서드는 코드의 재사용성과 유지보수성을 높여주는 도구입니다. 적절하게 함수와 메서드를 활용하여 코드를 구성하고, 가독성과 유연성을 고려하여 함수와 메서드를 설계하시기 바랍니다.</p>\n<h3>2.4. 컴포넌트</h3>\n<p>클래스와 컴포넌트는 객체지향 프로그래밍과 리액트 프론트엔드 개발에서 중요한 개념입니다. 이 섹션에서는 클래스와 컴포넌트의 사용에 대한 가이드라인을 제시합니다.</p>\n<ol>\n<li>컴포넌트의 정의\n<ul>\n<li>컴포넌트는 UI의 독립적인 구성 요소입니다. 화면에 특정한 기능을 가진 모듈 형태로 나타낼 수 있습니다.</li>\n<li>리액트에서 컴포넌트는 클래스로 정의될 수도 있고, 함수로 정의될 수도 있습니다. 클래스 컴포넌트와 함수형 컴포넌트가 있습니다.</li>\n</ul>\n</li>\n<li>컴포넌트의 명명 규칙\n<ul>\n<li>컴포넌트의 이름은 대문자로 시작해야 합니다.</li>\n<li>컴포넌트의 이름은 명사나 명사구로 짓는 것이 일반적입니다. 예: User, LoginForm, Header</li>\n</ul>\n</li>\n<li>상속과 확장성\n<ul>\n<li>컴포넌트는 상속을 통해 기존의 컴포넌트를 확장할 수 있습니다. 이를 통해 코드의 재사용성과 확장성을 높일 수 있습니다.</li>\n<li>상속을 사용할 때는 상속받은 컴포넌트의 기능을 잘 이해하고, 필요한 부분을 재정의하여 사용해야 합니다.</li>\n</ul>\n</li>\n</ol>\n<p>컴포넌트는 객체지향 개념과 리액트 개발에서 핵심적인 역할을 수행합니다.컴포넌트를 잘 이해하고 적절하게 활용하여 유지보수 가능하고 확장성 있는 코드를 작성해야 합니다.</p>\n<h3>2.5. 주석</h3>\n<p>주석은 코드에 대한 설명이나 추가 정보를 제공하기 위해 사용됩니다. 올바른 주석 작성은 코드의 가독성과 유지보수성을 향상시키는 데 도움이 됩니다. 아래는 주석 작성에 대한 가이드라인입니다.</p>\n<ol>\n<li>주석의 목적\n<ul>\n<li>주석의 사용을 최대한 지양하며 필수적인 경우에만 사용합니다.</li>\n<li>중요한 사항이나 추후에 작업을 필요로하는 부분을 강조하는 주석을 작성합니다.</li>\n</ul>\n</li>\n<li>주석의 작성 규칙\n<ul>\n<li>주석은 명확하고 간결하게 작성되어야 합니다.</li>\n<li>주석은 코드에 비해 적절한 수로 작성되어야 합니다. 과도한 주석은 코드를 가독성이 떨어뜨릴 수 있습니다.</li>\n<li>주석은 필요한 부분에 작성되어야 하며, 필요 없는 주석은 삭제되어야 합니다.</li>\n<li>주석은 코드의 변경에 따라 업데이트되어야 합니다.</li>\n</ul>\n</li>\n</ol>\n<p>주석은 코드를 이해하고 유지보수하기 쉽게 만들어줍니다. 주석을 적절하게 작성하여 코드를 더욱 명확하고 의미 있는 형태로 유지해야 합니다.</p>\n<h3>2.6. 네이밍 규칙</h3>\n<p>일관된 네이밍 규칙은 코드의 가독성과 일관성을 유지하는 데 중요합니다. 아래는 네이밍 규칙에 대한 가이드라인입니다.</p>\n<ol>\n<li>변수와 상수 네이밍\n<ul>\n<li>의미 전달: 변수와 상수의 이름은 해당 값을 잘 설명해야 합니다. 다른 개발자들이 이름만으로 변수의 역할과 용도를 이해할 수 있어야 합니다.</li>\n<li>카멜 케이스: 변수와 상수의 이름은 카멜 케이스를 사용합니다. 첫 단어는 소문자로 시작하고, 이후 단어의 첫 글자는 대문자로 작성합니다. 예: firstName, userAge</li>\n<li>가독성: 변수의 길이는 적절하게 설정해야 합니다. 너무 짧으면 의미 전달이 어려우며, 너무 길면 가독성이 저하될 수 있습니다.</li>\n</ul>\n</li>\n<li>함수와 메서드 네이밍\n<ul>\n<li>동사 형태: 함수와 메서드의 이름은 동사로 시작해야 합니다. 동작하는 기능을 잘 설명하는 동사를 선택합니다. 예: getUserData, calculateTotal</li>\n<li>카멜 케이스: 함수와 메서드의 이름은 카멜 케이스를 사용합니다. 첫 단어는 소문자로 시작하고, 이후 단어의 첫 글자는 대문자로 작성합니다. 예: fetchData, updateProfile</li>\n</ul>\n</li>\n<li>컴포넌트 네이밍\n<ul>\n<li>파스칼 케이스: 컴포넌트의 이름은 파스칼 케이스를 사용합니다. 모든 단어의 첫 글자를 대문자로 작성하고, 단어 사이에는 공백이 없습니다. 예: UserService, HomePage</li>\n<li>명확한 역할: 클래스와 컴포넌트의 이름은 해당 역할을 명확하게 전달해야 합니다. 다른 개발자들이 이름만으로 해당 클래스나 컴포넌트의 역할을 이해할 수 있어야 합니다.</li>\n</ul>\n</li>\n<li>폴더 디렉토리 파일 네이밍: routes와 type폴더를 제외하고 src의 모든 폴더 내의 파일의 이름은 index로 통일합니다.\n<ul>\n<li>컴포넌트 폴더\n<ul>\n<li>대문자와 파스칼 케이스: 파일의 이름은 첫 글자를 대문자로 작성하고, 단어 사이에는 공백이 없습니다</li>\n</ul>\n</li>\n<li>이외의 폴더\n<ul>\n<li>소문자와 하이픈: 파일의 이름은 소문자로 작성하며, 여러 단어는 하이픈으로 구분합니다. 예: user-service.js, home-page.tsx</li>\n</ul>\n</li>\n<li>파일 확장자: 파일의 확장자는 해당 파일의 유형에 맞게 설정합니다. 예: .ts, .tsx</li>\n</ul>\n</li>\n</ol>\n<p>일관된 네이밍 규칙을 따르면 코드의 가독성이 향상되고 협업 시에도 일관성을 유지할 수 있습니다. 모든 개발자들이 네이밍 규칙을 공유하고 준수하도록 합니다.</p>\n<h3>2.7. 코드 포맷팅</h3>\n<p>일관된 코드 포맷팅은 가독성을 향상시키고 협업을 용이하게 만듭니다.</p>\n<p>아래는 코드 포맷팅에 대한 가이드라인이며 순서대로 구성됩니다.</p>\n<ul>\n<li>\n<p>대분류(1,2,3…)를 기준으로 한 줄 띄웁니다.</p>\n</li>\n<li>\n<p>소분류(a,b,c…)는 띄우지 않습니다.</p>\n<ol>\n<li>\n<p>import Module</p>\n<pre><code class=\"language-jsx\">import {\n  Box,\n  Flex,\n  FormControl,\n  FormLabel,\n  Input,\n} from \"@chakra-ui/react\";\nimport { useMemo } from \"react\";\nimport { useForm } from \"react-hook-form\";\n\n<p>import { CodeSelect } from &quot;@mobyen-frontend/common&quot;;<br>import useUserRoles from &quot;features/user/hooks/useUserRoles&quot;;<br></code></pre></p>\n<ol>\n<li>외부 모듈: from 이후를 기준, 알파벳 순으로 정렬합니다.</li>\n<li>내부 모듈: from 이후를 기준, 알파벳 순으로 정렬합니다.</li>\n</ol>\n</li>\n<li>\n<p>interface: 스코프 내에 있는 내용을 알파벳 순서대로 정렬합니다.</p>\n<pre><code class=\"language-jsx\">interface SearchPanelProps {\n  isSearching: boolean;\n  onChange: (param: {\n    email: string | null,\n    ext: string | null,\n    mobile: string | null,\n    name: string | null,\n    tel: string | null,\n    userRole: string | null,\n    useYN: string | null,\n  }) => void;\n  onReset: () => void;\n}\n</code></pre>\n</li>\n<li>\n<p>defaultProps: 스코프 내에 있는 내용을 알파벳 순서대로 정렬합니다.</p>\n<pre><code class=\"language-jsx\">const defaultProps = {\n  isSearching: false,\n  onChange(_param: {\n    email: null,\n    ext: null,\n    mobile: null,\n    name: null,\n    tel: null,\n    userRole: null,\n    useYN: null,\n  }) {},\n  onReset() {},\n};\n</code></pre>\n</li>\n<li>\n<p>component</p>\n<pre><code class=\"language-jsx\">function SearchPanel({ isSearching, onChange, onReset }: SearchPanelProps) {\n  const { handleSubmit, register, reset, resetField } = useForm&#x3C;{\n    search: string;\n    searchType?: \"email\" | \"ext\" | \"mobile\" | \"name\" | \"tel\";\n    useYN: string;\n    userRole: string;\n  }>();\n\n<p>  const { data: userRoles } = useUserRoles({ publicYN: &quot;Y&quot; });</p>\n<p>  const handleFormSubmit = handleSubmit(<br>    ({ search, searchType, userRole, useYN }) =&gt; {<br>      let email = null;<br>      let ext = null;<br>      let mobile = null;<br>      let name = null;<br>      let tel = null;<br>      if (searchType) {<br>        email = searchType === &quot;email&quot; ? search : null;<br>        ext = searchType === &quot;ext&quot; ? search : null;<br>        mobile = searchType === &quot;mobile&quot; ? search : null;<br>        name = searchType === &quot;name&quot; ? search : null;<br>        tel = searchType === &quot;tel&quot; ? search : null;<br>      } else {<br>        resetField(&quot;search&quot;);<br>      }<br>      onChange({<br>        email: email ?? null,<br>        ext: ext ?? null,<br>        mobile: mobile ?? null,<br>        name: name ?? null,<br>        tel: tel ?? null,<br>        userRole: userRole ? userRole : null,<br>        useYN: useYN ? useYN : null,<br>      });<br>    }<br>  );</p>\n<p>  const handleResetButtonClick = () =&gt; {<br>    reset();<br>    onReset();<br>  };</p>\n<p>  const userRoleOptions = useMemo(<br>    () =&gt;<br>      userRoles?.map((role) =&gt; ({<br>        code: String(role.id),<br>        name: role.name ?? &quot;&quot;,<br>      })) ?? [],<br>    [userRoles]<br>  );<br>  const searchTypeOption = [<br>    {<br>      code: &quot;name&quot;,<br>      name: &quot;이름&quot;,<br>    },<br>    {<br>      code: &quot;email&quot;,<br>      name: &quot;이메일&quot;,<br>    },<br>    {<br>      code: &quot;tel&quot;,<br>      name: &quot;전화번호&quot;,<br>    },<br>    {<br>      code: &quot;ext&quot;,<br>      name: &quot;내선번호&quot;,<br>    },<br>    {<br>      code: &quot;mobile&quot;,<br>      name: &quot;휴대폰번호&quot;,<br>    },<br>  ];</p>\n<p>  return (<br>    &#x3C;Flex<br>      as=&quot;form&quot;<br>      flexDirection=&quot;column&quot;<br>      gap={2}<br>      onSubmit={handleFormSubmit}<br>      width=&quot;100%&quot;<br>    &gt;<br>      &#x3C;Box<br>        borderBottomColor=&quot;black&quot;<br>        borderBottomWidth=&quot;1px&quot;<br>        borderTopColor=&quot;black&quot;<br>        borderTopWidth=&quot;1px&quot;<br>        p={3}<br>      &gt;<br>        &#x3C;FormControl&gt;<br>          &#x3C;FormLabel fontSize=&quot;xs&quot; fontWeight=&quot;bold&quot; htmlFor=&quot;userRole&quot;&gt;<br>            검색조건<br>          &#x3C;/FormLabel&gt;<br>          &#x3C;Flex flexWrap=&quot;wrap&quot; gap={2}&gt;<br>            &#x3C;CodeSelect<br>              codes={userRoleOptions}<br>              flex={{ md: 1 }}<br>              id=&quot;userRole&quot;<br>              minWidth={{ md: &quot;150px&quot; }}<br>              maxWidth={{ lg: &quot;200px&quot; }}<br>              placeholder=&quot;권한&quot;<br>              {...register(&quot;userRole&quot;)}<br>            /&gt;<br>            &#x3C;CodeSelect<br>              codes={[<br>                { code: &quot;Y&quot;, name: &quot;사용&quot; },<br>                { code: &quot;N&quot;, name: &quot;미사용&quot; },<br>              ]}<br>              flex={{ sm: 1 }}<br>              id=&quot;useYN&quot;<br>              maxWidth={{ lg: &quot;200px&quot; }}<br>              minWidth={{ md: &quot;150px&quot; }}<br>              placeholder=&quot;사용여부&quot;<br>              {...register(&quot;useYN&quot;)}<br>            /&gt;<br>            &#x3C;CodeSelect<br>              codes={searchTypeOption}<br>              flex={{ sm: 1 }}<br>              id=&quot;searchType&quot;<br>              maxWidth={{ lg: &quot;170px&quot; }}<br>              minWidth={{ md: &quot;130px&quot; }}<br>              placeholder=&quot;검색조건&quot;<br>              {...register(&quot;searchType&quot;)}<br>            /&gt;<br>            &#x3C;Input<br>              flex={{ md: 2 }}<br>              id=&quot;search&quot;<br>              maxWidth={{ lg: &quot;300px&quot; }}<br>              minWidth={{ md: &quot;200px&quot; }}<br>              placeholder=&quot;검색어&quot;<br>              {...register(&quot;search&quot;)}<br>            /&gt;<br>            &#x3C;Input<br>              disabled={isSearching}<br>              hidden<br>              id=&quot;searchButton&quot;<br>              type=&quot;submit&quot;<br>            /&gt;<br>            &#x3C;Input<br>              hidden<br>              id=&quot;resetButton&quot;<br>              type=&quot;button&quot;<br>              onClick={handleResetButtonClick}<br>            /&gt;<br>          &#x3C;/Flex&gt;<br>        &#x3C;/FormControl&gt;<br>      &#x3C;/Box&gt;<br>    &#x3C;/Flex&gt;<br>  );<br>}<br></code></pre></p>\n<ol>\n<li>리액트 훅: 선언 명을 기준, 알파벳 순으로 정렬합니다.</li>\n<li>커스텀 훅: 선언 명을 기준, 알파벳 순으로 정렬합니다.</li>\n<li>useState: 첫 번째 상태변수를 기준, 알파벳 순으로 정렬합니다.</li>\n<li>function: 선언 명을 기준, 알파벳 순으로 정렬합니다.</li>\n<li>useEffect</li>\n<li>watch 함수</li>\n</ol>\n</li>\n<li>\n<p>defaultProps</p>\n<pre><code class=\"language-jsx\">SearchPanel.defaultProps = defaultProps;\n</code></pre>\n</li>\n<li>\n<p>export default</p>\n<pre><code class=\"language-jsx\">export default SearchPanel;\n</code></pre>\n</li>\n</ol>\n</li>\n</ul>\n<h3>2.8. 에러 처리</h3>\n<p>애플리케이션에서 발생하는 에러를 적절히 처리하는 것은 안정성과 예외 상황에 대한 대응력을 향상시킵니다. 아래는 에러 처리에 대한 가이드라인입니다.</p>\n<ol>\n<li>예외 처리: 예외 상황이 발생할 수 있는 코드 블록에는 적절한 예외 처리를 구현합니다. 이는 try-catch 문을 사용하여 예외를 캐치하고, 적절한 로그 메시지를 출력하거나 사용자에게 에러 메시지를 표시하는 등의 처리를 수행합니다.</li>\n<li>에러 핸들링: 애플리케이션의 최상위 수준에서 에러 핸들링을 구현합니다. 이는 예상치 못한 예외 상황이 발생했을 때 알림을 표시하고, 사용자에게 적절한 안내를 제공하는 등의 처리를 수행합니다.</li>\n<li>로깅: 에러 발생 시 로그를 기록하고 추적 가능한 정보를 포함시킵니다. 이는 디버깅과 문제 해결에 도움을 줄 수 있습니다.</li>\n<li>사용자 피드백: 에러 발생 시 사용자에게 적절한 피드백을 제공합니다. 이는 사용자가 문제 상황을 이해하고 대처할 수 있도록 도움을 줄 수 있습니다.</li>\n<li>예외 처리 모듈: 애플리케이션에서 공통적으로 발생하는 예외 상황에 대한 처리를 모듈화하여 재사용성을 높일 수 있습니다.</li>\n</ol>\n<p>애플리케이션에서 발생할 수 있는 예외 상황을 사전에 고려하고, 적절한 에러 처리를 구현하여 안정성과 사용자 경험을 개선하는 것이 좋습니다.</p>\n<h2>3. 프로젝트 구조</h2>\n<h3>3.1. 파일 및 폴더 구조</h3>\n<pre><code class=\"language-jsx\">- `package`: 프로젝트의 루트 디렉토리\n    - `app`: 애플리케이션의 소스 코드와 관련된 디렉토리\n        - `node_modules`: 프로젝트의 의존성 패키지들이 설치되는 디렉토리\n        - `public`: 정적 파일이 위치하는 디렉토리\n        - `src`: 소스 코드가 위치하는 디렉토리입니다.\n            - `api`: 서버 API와 통신하는 코드가 위치하는 디렉토리입니다.\n            - `assets`: 애플리케이션에서 사용되는 정적 리소스(이미지, 아이콘 등)가 위치\n            - `components`: 재사용 가능한 React 컴포넌트들이 위치하는 디렉토리\n            - `features`: 애플리케이션의 기능별로 구성된 모듈이 위치하는 디렉토리\n            - `libs`: 애플리케이션에서 사용되는 유틸리티 함수, 헬퍼 클래스 등이 위치\n            - `redux`: 리덕스의 리듀서, 액션, 미들웨어 등이 포함됩니다.\n            - `routes`: 라우팅과 관련된 코드가 위치하는 디렉토리입니다.\n            - `type`: 타입 정의 파일이 위치하는 디렉토리입니다.\n            - `App.css`: 애플리케이션 전체에 적용되는 CSS 스타일을 정의\n            - `App.test.tsx`: 애플리케이션의 테스트 코드가 위치하는 파일\n            - `index.css`: index.html 파일에서 사용되는 전역 CSS 스타일을 정의하는 파일\n            - `index.tsx`: React DOM 렌더링을 수행하는 코드가 이 파일에 포함됩니다.\n            - `react-app-env.d.ts`: Create React App에 의해 자동 생성되는 TypeScript 환경 설정 파일\n            - `reportWebVitals.ts`: 웹 애플리케이션의 성능 측정을 위한 코드가 위치하는 파일\n            - `setupProxy.js`: 개발 환경에서 프록시 설정을 위한 파일, 개발 서버와 API 서버 간의 통신을 프록시하는데 사용됩니다.\n            - `setupTest.ts`: 테스트 환경 설정을 위한 파일\n            - `theme.ts`: 애플리케이션의 테마 설정을 관리하는 파일\n    - `common`: 재사용되는 코드나 모듈들을 관리하는 디렉토리\n        - `dist`: 재사용되는 코드의 빌드 결과물이 위치하는 디렉토리\n        - `src`: 재사용되는 코드의 소스 파일들이 위치하는 디렉토리\n        - `package.json`: 재사용되는 코드의 의존성 패키지들을 관리하는 파일\n        - `tsconfig.json`: 재사용되는 코드의 TypeScript 환경 설정 파일\n</code></pre>\n<h3>3.2. 모듈화와 컴포넌트 구성</h3>\n<p>모듈화와 컴포넌트 구성은 코드의 재사용성과 유지보수성을 높이는 중요한 요소입니다. 아래는 모듈화와 컴포넌트 구성에 대한 가이드라인입니다.</p>\n<ol>\n<li>모듈화:\n<ul>\n<li>기능 단위로 모듈을 분리하여 개발합니다. 각 모듈은 특정 기능을 수행하도록 설계되며, 관련된 코드와 리소스를 포함해야 합니다.</li>\n<li>모듈 간의 의존성을 최소화하고, 각 모듈이 독립적으로 작동할 수 있도록 설계합니다. 이는 모듈 간의 결합도를 낮추고 유연성을 높일 수 있습니다.</li>\n<li>모듈의 인터페이스를 명확하게 정의하고, 다른 모듈에서 재사용할 수 있는 API를 제공합니다.</li>\n<li>모듈의 구현을 추상화하고, 내부 구현의 변경에 유연하게 대처할 수 있도록 설계합니다.</li>\n</ul>\n</li>\n<li>컴포넌트 구성:\n<ul>\n<li>컴포넌트는 UI 요소의 재사용 가능한 조합입니다. 비슷한 동작을 하는 UI 요소들을 하나의 컴포넌트로 추상화하고, 필요에 따라 다양한 속성을 통해 재사용할 수 있도록 설계합니다.</li>\n<li>컴포넌트는 단일 책임 원칙을 준수하고, 가능한 한 작고 재사용 가능한 형태로 구성합니다. 이는 컴포넌트의 이해와 유지보수를 용이하게 합니다.</li>\n<li>컴포넌트 간의 계층 구조를 구성하여, 복잡한 UI를 단순화하고 관리 가능한 단위로 분할합니다. 이는 코드의 가독성과 유지보수성을 향상시킵니다.</li>\n<li>컴포넌트의 인터페이스를 명확하게 정의하고, 다른 컴포넌트와의 상호작용을 규정합니다.</li>\n<li>컴포넌트 간의 상태 공유를 최소화하고, 필요한 데이터는 프로퍼티로 전달하여 컴포넌트 간의 독립성을 유지합니다.</li>\n</ul>\n</li>\n</ol>\n<p>모듈화와 컴포넌트 구성은 코드의 구조를 개선하고, 재사용 가능한 코드의 양을 늘리는데 중요한 역할을 합니다. 적절한 모듈화와 컴포넌트 구성을 통해 개발 생산성과 코드 품질을 향상시킬 수 있습니다.</p>\n<h3>3.3. 상태 관리</h3>\n<p>상태 관리는 애플리케이션에서 데이터의 상태를 효과적으로 관리하는 것을 의미합니다. 아래는 상태 관리에 대한 가이드라인입니다.</p>\n<ol>\n<li>단일 소스로 상태 관리하기:\n<ul>\n<li>애플리케이션의 모든 상태를 단일한 곳에서 관리하는 것이 중요합니다. 이를 통해 상태의 일관성을 유지하고, 데이터의 중복을 피할 수 있습니다.</li>\n<li>상태 관리 라이브러리인 Redux 사용하여 상태를 중앙 집중화합니다.</li>\n</ul>\n</li>\n<li>상태의 불변성 유지:\n<ul>\n<li>상태는 불변성을 유지해야 합니다. 이는 상태를 직접 수정하지 않고 새로운 상태를 생성하여 업데이트하는 방식으로 작업해야 함을 의미합니다.</li>\n</ul>\n</li>\n<li>컴포넌트와 상태의 연결:\n<ul>\n<li>상태 관리 라이브러리를 활용하면 컴포넌트와 상태를 쉽게 연결할 수 있습니다. 이를 통해 상태의 변경을 자동으로 감지하고 컴포넌트를 업데이트할 수 있습니다.</li>\n<li>React의 Context API, ReactQuery 등을 활용하여 컴포넌트와 상태를 연결하고 패칭합니다.</li>\n</ul>\n</li>\n<li>비동기 상태 관리:\n<ul>\n<li>비동기 작업과 관련된 상태를 효과적으로 관리해야 합니다. API 호출, 비동기 데이터 로딩 등의 작업을 처리하는데 있어서 상태 관리 라이브러리의 비동기 처리 기능을 활용할 수 있습니다.</li>\n<li>Redux-Thunk를 사용하여 비동기 작업을 처리합니다.</li>\n</ul>\n</li>\n</ol>\n<h3>3.4. 라우팅</h3>\n<p>라우팅은 사용자가 애플리케이션 내에서 다른 페이지 또는 뷰로 이동할 수 있는 기능을 제공하는 것입니다. 아래는 라우팅에 대한 가이드라인입니다.</p>\n<ol>\n<li>라우팅 라이브러리 선택:\n<ul>\n<li>React 애플리케이션에서 라우팅을 구현하기 위해 React Router 라우팅 라이브러리를 사용합니다.</li>\n</ul>\n</li>\n<li>라우팅 구성:\n<ul>\n<li>라우팅은 URL 경로와 해당 경로에 연결된 컴포넌트를 매핑하는 방식으로 구성됩니다.</li>\n<li>라우터 컴포넌트를 사용하여 URL 경로와 컴포넌트를 매핑하고, 필요에 따라 중첩된 라우트와 파라미터를 처리할 수 있습니다.</li>\n</ul>\n</li>\n<li>네비게이션:\n<ul>\n<li>사용자가 다른 페이지로 이동할 수 있도록 네비게이션 기능을 구현합니다.</li>\n<li>useNavigate와 react-router-dom의 Navigate를 사용하여 라우터를 조작하여 네비게이션을 처리합니다.</li>\n</ul>\n</li>\n<li>보안과 권한 관리:\n<ul>\n<li>라우팅 시 보안 및 권한 관리가 필요한 경우, 인증 여부를 확인하고 접근 권한을 제어합니다.\n<ul>\n<li>AppLayout: 토큰인증이 요구되는 접근 영역</li>\n<li>NonAuthenticationLayout: 비인증 상태 접근 영역</li>\n</ul>\n</li>\n<li>보호된 라우트, 권한 검사 및 리다이렉션과 같은 기능을 구현하여 보안과 권한 관리를 처리할 수 있습니다.</li>\n</ul>\n</li>\n</ol>\n<p>라우팅은 사용자 경험을 향상시키고, 애플리케이션 내의 다양한 기능과 페이지 간의 이동을 가능하게 합니다. 적절한 라우팅 구현은 사용자의 효율성과 편의성을 높이는 데 중요한 역할을 합니다.</p>\n<h2>4. 리소스 관리</h2>\n<h3>4.1. 이미지 및 아이콘</h3>\n<p>이미지 및 아이콘은 애플리케이션에서 시각적인 요소를 추가하고 사용자 경험을 향상시키는 데 중요한 역할을 합니다. 아래는 이미지 및 아이콘 사용에 대한 가이드라인입니다.</p>\n<ol>\n<li>이미지 사용:\n<ul>\n<li>애플리케이션에서 이미지를 사용하여 콘텐츠를 시각적으로 표현할 수 있습니다.</li>\n<li>이미지를 삽입할 때는 최적화된 이미지를 사용하여 로딩 속도를 개선하고, 반응형 디자인에 맞게 이미지 크기를 조정해야 합니다.</li>\n<li>이미지에 대체 텍스트를 제공하여 시각 장애인이나 이미지 로딩에 실패한 경우에도 콘텐츠를 이해할 수 있도록 해야 합니다.</li>\n</ul>\n</li>\n<li>아이콘 사용:\n<ul>\n<li>아이콘은 작고 간결한 그래픽 요소로서 애플리케이션에서 기능이나 상태를 시각적으로 나타내는 데 유용합니다.</li>\n<li>아이콘 라이브러리로 Font Awesome를 사용합니다.</li>\n<li>아이콘은 의미를 명확하게 전달해야 하므로, 사용 시 해당 아이콘의 의미와 사용 범위를 이해하고 적절하게 활용해야 합니다.</li>\n</ul>\n</li>\n<li>이미지 및 아이콘 관리:\n<ul>\n<li>이미지 및 아이콘은 프로젝트의 assets 디렉토리에서 관리됩니다.</li>\n</ul>\n</li>\n</ol>\n<h3>4.2. 스타일시트.</h3>\n<p>스타일시트는 애플리케이션의 외관과 레이아웃을 결정하는 중요한 요소입니다. Chakra UI와 같은 스타일시트 라이브러리를 사용하면 일관된 디자인 시스템을 구축하고 UI 개발을 효율적으로 진행할 수 있습니다. 아래는 Chakra UI를 사용한 스타일시트 작성에 대한 가이드라인입니다.</p>\n<ol>\n<li>Chakra UI:\n<ul>\n<li>프로젝트에 Chakra UI가 설치되어있습니다.</li>\n<li>ChakraProvider는 애플리케이션의 최상위에 Chakra UI가 적용되어 있습니다.</li>\n</ul>\n</li>\n<li>컴포넌트 스타일링:\n<ul>\n<li>Chakra UI는 다양한 사전 정의된 컴포넌트와 스타일 프로퍼티를 제공합니다. 이를 활용하여 컴포넌트를 스타일링할 수 있습니다.</li>\n<li>스타일 프로퍼티를 사용하여 컴포넌트의 스타일을 변경하거나 커스터마이징할 수 있습니다.</li>\n<li>Chakra UI의 ThemeProvider를 사용하여 테마 설정을 관리하고 커스텀 테마를 적용할 수 있습니다.</li>\n</ul>\n</li>\n<li>반응형 디자인:\n<ul>\n<li>Chakra UI는 반응형 디자인을 지원하여 다양한 장치와 화면 크기에 대응할 수 있습니다.</li>\n<li>\"@chakra-ui/media-query\" 모듈을 사용하여 미디어 쿼리를 활용할 수 있습니다. 이를 활용하여 특정 화면 크기에 대한 스타일 조정합니다.</li>\n</ul>\n</li>\n<li>커스텀 컴포넌트:\n<ul>\n<li>필요에 따라 Chakra UI의 컴포넌트를 확장하여 커스텀 컴포넌트를 생성합니다.</li>\n<li>커스텀 컴포넌트를 생성하여 재사용성과 코드 유지 보수성을 향상킵니다.</li>\n</ul>\n</li>\n</ol>\n<p>Chakra UI를 사용하여 스타일시트를 작성하면 일관된 디자인 시스템을 구축하고 개발 생산성을 높일 수 있습니다. 적절하게 활용하여 사용자 인터페이스를 구성하고 디자인 요소를 일관되게 관리해야 합니다.</p>\n<h3>4.3. 외부 라이브러리와 의존성 관리</h3>\n<p>모던한 프론트엔드 애플리케이션 개발에는 종종 외부 라이브러리와 의존성이 필요합니다. 이러한 라이브러리와 의존성을 효율적으로 관리하고 활용하는 것이 중요합니다. 아래는 몇 가지 널리 사용되는 라이브러리와 의존성에 대한 간단한 소개입니다:</p>\n<ol>\n<li>emotion:\n<ul>\n<li>emotion은 CSS-in-JS 라이브러리로, JavaScript 코드 내에서 CSS 스타일을 작성할 수 있습니다. 컴포넌트 단위로 스타일을 캡슐화하여 유지보수 및 재사용성을 높일 수 있습니다.</li>\n</ul>\n</li>\n<li>reduxjs:\n<ul>\n<li>reduxjs는 상태 관리 라이브러리로, 애플리케이션의 상태를 중앙에서 관리하고 예측 가능한 상태 변화를 제공합니다. redux를 사용하여 복잡한 애플리케이션 상태를 효과적으로 관리할 수 있습니다.</li>\n</ul>\n</li>\n<li>ag-grid-react:\n<ul>\n<li>ag-grid-react는 강력한 그리드 컴포넌트 라이브러리로, 테이블 형태의 데이터를 표시하고 조작할 수 있습니다. 유연한 기능과 다양한 커스터마이징 옵션을 제공하여 데이터 그리드를 구축할 수 있습니다.</li>\n</ul>\n</li>\n<li>axios:\n<ul>\n<li>axios는 HTTP 클라이언트 라이브러리로, 비동기적으로 서버와 데이터 통신을 할 수 있습니다. REST API와의 상호작용이나 데이터 요청 처리에 유용합니다.</li>\n</ul>\n</li>\n<li>date-fns:\n<ul>\n<li>date-fns는 JavaScript 날짜 유틸리티 라이브러리로, 날짜와 시간 관련 작업을 쉽게 처리할 수 있습니다. 날짜 형식 변환, 날짜 계산, 로컬라이징 등 다양한 기능을 제공합니다.</li>\n</ul>\n</li>\n<li>framer-motion:\n<ul>\n<li>framer-motion은 React용 모션 및 애니메이션 라이브러리로, 화면 전환 및 요소 애니메이션을 부드럽게 구현할 수 있습니다. 유연한 애니메이션 효과와 상호작용을 제공합니다.</li>\n</ul>\n</li>\n<li>lodash:\n<ul>\n<li>lodash는 JavaScript 유틸리티 라이브러리로, 다양한 유용한 함수들을 제공합니다. 배열, 객체, 함수 등을 다루는 다양한 작업에 활용할 수 있습니다.</li>\n</ul>\n</li>\n<li>quill:\n<ul>\n<li>quill은 리치 텍스트 에디터 라이브러리로, 사용자가 서식 있는 텍스트를 작성하고 편집할 수 있는 기능을 제공합니다. 이미지, 표, 링크 등을 삽입할 수 있는 다양한 기능을 제공합니다.</li>\n</ul>\n</li>\n<li>react-datepicker:\n<ul>\n<li>react-datepicker는 React용 날짜 선택 컴포넌트 라이브러리로, 사용자가 날짜를 선택하고 입력할 수 있는 기능을 제공합니다. 다양한 날짜 형식과 옵션을 설정할 수 있습니다.</li>\n</ul>\n</li>\n<li>web-vitals:\n<ul>\n<li>web-vitals는 웹 애플리케이션의 성능 지표를 측정하는 라이브러리로, 사용자 경험을 평가하고 개선하는 데 도움을 줍니다. 측정된 지표를 통해 성능 최적화에 대한 통찰력을 얻을 수 있습니다.</li>\n</ul>\n</li>\n<li>xlsx:\n<ul>\n<li>xlsx는 Excel 파일을 다루는 라이브러리로, 데이터를 읽고 쓰는 기능을 제공합니다. Excel 파일 형식을 다루는 다양한 작업을 수행할 수 있습니다.</li>\n</ul>\n</li>\n<li>monaco-editor:\n<ul>\n<li>monaco-editor는 웹 기반의 텍스트 편집기 라이브러리로, 문법 강조, 자동 완성, 신택스 검증 등 다양한 기능을 제공합니다. 개발자용 IDE나 코드 에디터에 적용할 수 있습니다.</li>\n</ul>\n</li>\n</ol>\n<p>이러한 외부 라이브러리와 의존성을 적절하게 활용하여 개발 생산성을 향상시키고 애플리케이션에 필요한 기능을 구현할 수 있습니다. 의존성 관리와 버전 업데이트에 주의하여 안정성과 호환성을 유지하는 것이 중요합니다. 6. framer-motion:</p>\n<ul>\n<li>framer-motion은 React용 모션 및 애니메이션 라이브러리로, 화면 전환 및 요소 애니메이션을 부드럽게 구현할 수 있습니다. 유연한 애니메이션 효과와 상호작용을 제공합니다.</li>\n</ul>\n<ol start=\"7\">\n<li>lodash:\n<ul>\n<li>lodash는 JavaScript 유틸리티 라이브러리로, 다양한 유용한 함수들을 제공합니다. 배열, 객체, 함수 등을 다루는 다양한 작업에 활용할 수 있습니다.</li>\n</ul>\n</li>\n<li>quill:\n<ul>\n<li>quill은 리치 텍스트 에디터 라이브러리로, 사용자가 서식 있는 텍스트를 작성하고 편집할 수 있는 기능을 제공합니다. 이미지, 표, 링크 등을 삽입할 수 있는 다양한 기능을 제공합니다.</li>\n</ul>\n</li>\n<li>react-datepicker:\n<ul>\n<li>react-datepicker는 React용 날짜 선택 컴포넌트 라이브러리로, 사용자가 날짜를 선택하고 입력할 수 있는 기능을 제공합니다. 다양한 날짜 형식과 옵션을 설정할 수 있습니다.</li>\n</ul>\n</li>\n<li>web-vitals:\n<ul>\n<li>web-vitals는 웹 애플리케이션의 성능 지표를 측정하는 라이브러리로, 사용자 경험을 평가하고 개선하는 데 도움을 줍니다. 측정된 지표를 통해 성능 최적화에 대한 통찰력을 얻을 수 있습니다.</li>\n</ul>\n</li>\n<li>xlsx:\n<ul>\n<li>xlsx는 Excel 파일을 다루는 라이브러리로, 데이터를 읽고 쓰는 기능을 제공합니다. Excel 파일 형식을 다루는 다양한 작업을 수행할 수 있습니다.</li>\n</ul>\n</li>\n<li>monaco-editor:\n<ul>\n<li>monaco-editor는 웹 기반의 텍스트 편집기 라이브러리로, 문법 강조, 자동 완성, 신택스 검증 등 다양한 기능을 제공합니다. 개발자용 IDE나 코드 에디터에 적용할 수 있습니다.</li>\n</ul>\n</li>\n</ol>\n<p>이러한 외부 라이브러리와 의존성을 적절하게 활용하여 개발 생산성을 향상시키고 애플리케이션에 필요한 기능을 구현할 수 있습니다. 의존성 관리와 버전 업데이트에 주의하여 안정성과 호환성을 유지하는 것이 중요합니다.</p>\n","plainContent":"\n## 1. 목적\n\n1. 개발 표준화: 프론트엔드 개발에 일관성을 부여하여 코드의 가독성과 유지보수성을 높입니다.\n2. 팀 협업 강화: 개발자들 간의 협업을 원활하게 하고 의사소통을 개선합니다.\n3. 새로운 개발자 온보딩: 새로 합류한 개발자가 프로젝트에 빠르게 적응하고 효율적으로 개발할 수 있도록 돕습니다.\n4. 코드 품질 향상: 일관된 코딩 스타일과 최적화 기법을 적용하여 코드의 품질을 향상시킵니다.\n5. 유지보수성 강화: 일관된 구조와 명명 규칙을 통해 코드의 가독성을 높이고 유지보수를 용이하게 합니다.\n\n## 2. 코딩 스타일 가이드\n\n### 2.1. 들여쓰기\n\n1. Prettier의 기본설정으로 들여쓰기 합니다.\n\n### 2.2. 변수와 상수\n\n변수와 상수는 프론트엔드 개발에서 중요한 개념입니다. 이 섹션에서는 변수와 상수의 사용에 대한 가이드라인을 설명합니다.\n\n1. 변수명과 상수명\n   - 변수명과 상수명은 의미를 명확하게 전달할 수 있도록 짓는 것이 좋습니다.\n   - 변수명과 상수명은 영문을 사용하여 작성합니다.\n   - 여러 단어로 이루어진 경우에는 단어 사이를 카멜케이스로 구분합니다. 예: myVariable, userName\n2. 변수의 선언과 할당\n   - 변수를 선언할 때에는 let 키워드를 사용합니다. 예: let count = 0;\n   - 변수의 값은 필요에 따라 언제든지 변경할 수 있습니다.\n3. 상수의 선언과 할당\n   - 상수를 선언할 때에는 const 키워드를 사용합니다. 예: const PI = 3.14;\n   - 상수는 한 번 할당된 값은 변경할 수 없습니다.\n4. 변수와 상수의 초기화\n   - 변수와 상수는 선언과 동시에 초기값을 할당하는 것이 좋습니다.\n   - 초기화되지 않은 변수나 상수는 의도치 않은 동작을 야기할 수 있으므로 주의해야 합니다.\n\n변수와 상수는 프로그램의 데이터를 저장하고 조작하는 데에 필수적인 요소입니다. 적절하게 변수와 상수를 활용하여 가독성 높은 코드를 작성하고, 필요에 따라 값의 변경 여부를 고려하여 변수와 상수를 선택하시기 바랍니다.\n\n### 2.3. 함수와 메서드\n\n함수와 메서드는 프론트엔드 개발에서 코드의 재사용성과 모듈화를 위해 중요한 요소입니다. 이 섹션에서는 함수와 메서드의 사용에 대한 가이드라인을 제시합니다.\n\n1. 함수와 메서드의 정의\n   - 함수는 독립적으로 동작하는 코드 블록입니다. 주어진 입력을 받아서 처리하고, 결과를 반환할 수 있습니다.\n   - 메서드는 객체에 속해 있는 함수로, 객체의 상태를 조작하거나 객체의 동작을 수행합니다.\n2. 함수와 메서드의 명명 규칙\n   - 함수와 메서드의 이름은 동사 형태로 짓는 것이 일반적입니다. 예: calculateTotal, loginUser\n   - 함수와 메서드의 이름은 의미를 명확하게 전달할 수 있도록 작성해야 합니다.\n   - 여러 단어로 이루어진 경우에는 카멜 케이스(camelCase)를 사용하여 작성합니다. 예: calculateTaxAmount, loginUserWithCredentials\n3. 함수와 메서드의 매개변수\n   - 함수와 메서드는 필요한 입력값을 매개변수(parameter)로 받을 수 있습니다.\n   - 매개변수의 이름은 변수와 동일한 명명 규칙을 따르며, 입력값의 의미를 잘 표현할 수 있도록 작성해야 합니다.\n4. 함수와 메서드의 반환값\n   - 함수와 메서드는 필요에 따라 결과값을 반환할 수 있습니다.\n   - 반환값의 타입은 명확하게 정의하고, 함수 또는 메서드의 목적과 일치하는 데이터를 반환해야 합니다.\n5. 함수와 메서드의 범위\n   - 함수와 메서드는 선언된 블록(scope) 내에서 유효합니다. 함수 내부에서 선언된 변수는 함수 내에서만 사용할 수 있으며, 함수 외부에서는 접근할 수 없습니다.\n\n함수와 메서드는 코드의 재사용성과 유지보수성을 높여주는 도구입니다. 적절하게 함수와 메서드를 활용하여 코드를 구성하고, 가독성과 유연성을 고려하여 함수와 메서드를 설계하시기 바랍니다.\n\n### 2.4. 컴포넌트\n\n클래스와 컴포넌트는 객체지향 프로그래밍과 리액트 프론트엔드 개발에서 중요한 개념입니다. 이 섹션에서는 클래스와 컴포넌트의 사용에 대한 가이드라인을 제시합니다.\n\n1. 컴포넌트의 정의\n   - 컴포넌트는 UI의 독립적인 구성 요소입니다. 화면에 특정한 기능을 가진 모듈 형태로 나타낼 수 있습니다.\n   - 리액트에서 컴포넌트는 클래스로 정의될 수도 있고, 함수로 정의될 수도 있습니다. 클래스 컴포넌트와 함수형 컴포넌트가 있습니다.\n2. 컴포넌트의 명명 규칙\n   - 컴포넌트의 이름은 대문자로 시작해야 합니다.\n   - 컴포넌트의 이름은 명사나 명사구로 짓는 것이 일반적입니다. 예: User, LoginForm, Header\n3. 상속과 확장성\n   - 컴포넌트는 상속을 통해 기존의 컴포넌트를 확장할 수 있습니다. 이를 통해 코드의 재사용성과 확장성을 높일 수 있습니다.\n   - 상속을 사용할 때는 상속받은 컴포넌트의 기능을 잘 이해하고, 필요한 부분을 재정의하여 사용해야 합니다.\n\n컴포넌트는 객체지향 개념과 리액트 개발에서 핵심적인 역할을 수행합니다.컴포넌트를 잘 이해하고 적절하게 활용하여 유지보수 가능하고 확장성 있는 코드를 작성해야 합니다.\n\n### 2.5. 주석\n\n주석은 코드에 대한 설명이나 추가 정보를 제공하기 위해 사용됩니다. 올바른 주석 작성은 코드의 가독성과 유지보수성을 향상시키는 데 도움이 됩니다. 아래는 주석 작성에 대한 가이드라인입니다.\n\n1. 주석의 목적\n   - 주석의 사용을 최대한 지양하며 필수적인 경우에만 사용합니다.\n   - 중요한 사항이나 추후에 작업을 필요로하는 부분을 강조하는 주석을 작성합니다.\n2. 주석의 작성 규칙\n   - 주석은 명확하고 간결하게 작성되어야 합니다.\n   - 주석은 코드에 비해 적절한 수로 작성되어야 합니다. 과도한 주석은 코드를 가독성이 떨어뜨릴 수 있습니다.\n   - 주석은 필요한 부분에 작성되어야 하며, 필요 없는 주석은 삭제되어야 합니다.\n   - 주석은 코드의 변경에 따라 업데이트되어야 합니다.\n\n주석은 코드를 이해하고 유지보수하기 쉽게 만들어줍니다. 주석을 적절하게 작성하여 코드를 더욱 명확하고 의미 있는 형태로 유지해야 합니다.\n\n### 2.6. 네이밍 규칙\n\n일관된 네이밍 규칙은 코드의 가독성과 일관성을 유지하는 데 중요합니다. 아래는 네이밍 규칙에 대한 가이드라인입니다.\n\n1. 변수와 상수 네이밍\n   - 의미 전달: 변수와 상수의 이름은 해당 값을 잘 설명해야 합니다. 다른 개발자들이 이름만으로 변수의 역할과 용도를 이해할 수 있어야 합니다.\n   - 카멜 케이스: 변수와 상수의 이름은 카멜 케이스를 사용합니다. 첫 단어는 소문자로 시작하고, 이후 단어의 첫 글자는 대문자로 작성합니다. 예: firstName, userAge\n   - 가독성: 변수의 길이는 적절하게 설정해야 합니다. 너무 짧으면 의미 전달이 어려우며, 너무 길면 가독성이 저하될 수 있습니다.\n2. 함수와 메서드 네이밍\n   - 동사 형태: 함수와 메서드의 이름은 동사로 시작해야 합니다. 동작하는 기능을 잘 설명하는 동사를 선택합니다. 예: getUserData, calculateTotal\n   - 카멜 케이스: 함수와 메서드의 이름은 카멜 케이스를 사용합니다. 첫 단어는 소문자로 시작하고, 이후 단어의 첫 글자는 대문자로 작성합니다. 예: fetchData, updateProfile\n3. 컴포넌트 네이밍\n   - 파스칼 케이스: 컴포넌트의 이름은 파스칼 케이스를 사용합니다. 모든 단어의 첫 글자를 대문자로 작성하고, 단어 사이에는 공백이 없습니다. 예: UserService, HomePage\n   - 명확한 역할: 클래스와 컴포넌트의 이름은 해당 역할을 명확하게 전달해야 합니다. 다른 개발자들이 이름만으로 해당 클래스나 컴포넌트의 역할을 이해할 수 있어야 합니다.\n4. 폴더 디렉토리 파일 네이밍: routes와 type폴더를 제외하고 src의 모든 폴더 내의 파일의 이름은 index로 통일합니다.\n   - 컴포넌트 폴더\n     - 대문자와 파스칼 케이스: 파일의 이름은 첫 글자를 대문자로 작성하고, 단어 사이에는 공백이 없습니다\n   - 이외의 폴더\n     - 소문자와 하이픈: 파일의 이름은 소문자로 작성하며, 여러 단어는 하이픈으로 구분합니다. 예: user-service.js, home-page.tsx\n   - 파일 확장자: 파일의 확장자는 해당 파일의 유형에 맞게 설정합니다. 예: .ts, .tsx\n\n일관된 네이밍 규칙을 따르면 코드의 가독성이 향상되고 협업 시에도 일관성을 유지할 수 있습니다. 모든 개발자들이 네이밍 규칙을 공유하고 준수하도록 합니다.\n\n### 2.7. 코드 포맷팅\n\n일관된 코드 포맷팅은 가독성을 향상시키고 협업을 용이하게 만듭니다.\n\n아래는 코드 포맷팅에 대한 가이드라인이며 순서대로 구성됩니다.\n\n- 대분류(1,2,3…)를 기준으로 한 줄 띄웁니다.\n- 소분류(a,b,c…)는 띄우지 않습니다.\n\n  1. import Module\n\n     ```jsx\n     import {\n       Box,\n       Flex,\n       FormControl,\n       FormLabel,\n       Input,\n     } from \"@chakra-ui/react\";\n     import { useMemo } from \"react\";\n     import { useForm } from \"react-hook-form\";\n\n     import { CodeSelect } from \"@mobyen-frontend/common\";\n     import useUserRoles from \"features/user/hooks/useUserRoles\";\n     ```\n\n     1. 외부 모듈: from 이후를 기준, 알파벳 순으로 정렬합니다.\n     2. 내부 모듈: from 이후를 기준, 알파벳 순으로 정렬합니다.\n\n  2. interface: 스코프 내에 있는 내용을 알파벳 순서대로 정렬합니다.\n\n     ```jsx\n     interface SearchPanelProps {\n       isSearching: boolean;\n       onChange: (param: {\n         email: string | null,\n         ext: string | null,\n         mobile: string | null,\n         name: string | null,\n         tel: string | null,\n         userRole: string | null,\n         useYN: string | null,\n       }) => void;\n       onReset: () => void;\n     }\n     ```\n\n  3. defaultProps: 스코프 내에 있는 내용을 알파벳 순서대로 정렬합니다.\n\n     ```jsx\n     const defaultProps = {\n       isSearching: false,\n       onChange(_param: {\n         email: null,\n         ext: null,\n         mobile: null,\n         name: null,\n         tel: null,\n         userRole: null,\n         useYN: null,\n       }) {},\n       onReset() {},\n     };\n     ```\n\n  4. component\n\n     ```jsx\n     function SearchPanel({ isSearching, onChange, onReset }: SearchPanelProps) {\n       const { handleSubmit, register, reset, resetField } = useForm<{\n         search: string;\n         searchType?: \"email\" | \"ext\" | \"mobile\" | \"name\" | \"tel\";\n         useYN: string;\n         userRole: string;\n       }>();\n\n       const { data: userRoles } = useUserRoles({ publicYN: \"Y\" });\n\n       const handleFormSubmit = handleSubmit(\n         ({ search, searchType, userRole, useYN }) => {\n           let email = null;\n           let ext = null;\n           let mobile = null;\n           let name = null;\n           let tel = null;\n           if (searchType) {\n             email = searchType === \"email\" ? search : null;\n             ext = searchType === \"ext\" ? search : null;\n             mobile = searchType === \"mobile\" ? search : null;\n             name = searchType === \"name\" ? search : null;\n             tel = searchType === \"tel\" ? search : null;\n           } else {\n             resetField(\"search\");\n           }\n           onChange({\n             email: email ?? null,\n             ext: ext ?? null,\n             mobile: mobile ?? null,\n             name: name ?? null,\n             tel: tel ?? null,\n             userRole: userRole ? userRole : null,\n             useYN: useYN ? useYN : null,\n           });\n         }\n       );\n\n       const handleResetButtonClick = () => {\n         reset();\n         onReset();\n       };\n\n       const userRoleOptions = useMemo(\n         () =>\n           userRoles?.map((role) => ({\n             code: String(role.id),\n             name: role.name ?? \"\",\n           })) ?? [],\n         [userRoles]\n       );\n       const searchTypeOption = [\n         {\n           code: \"name\",\n           name: \"이름\",\n         },\n         {\n           code: \"email\",\n           name: \"이메일\",\n         },\n         {\n           code: \"tel\",\n           name: \"전화번호\",\n         },\n         {\n           code: \"ext\",\n           name: \"내선번호\",\n         },\n         {\n           code: \"mobile\",\n           name: \"휴대폰번호\",\n         },\n       ];\n\n       return (\n         <Flex\n           as=\"form\"\n           flexDirection=\"column\"\n           gap={2}\n           onSubmit={handleFormSubmit}\n           width=\"100%\"\n         >\n           <Box\n             borderBottomColor=\"black\"\n             borderBottomWidth=\"1px\"\n             borderTopColor=\"black\"\n             borderTopWidth=\"1px\"\n             p={3}\n           >\n             <FormControl>\n               <FormLabel fontSize=\"xs\" fontWeight=\"bold\" htmlFor=\"userRole\">\n                 검색조건\n               </FormLabel>\n               <Flex flexWrap=\"wrap\" gap={2}>\n                 <CodeSelect\n                   codes={userRoleOptions}\n                   flex={{ md: 1 }}\n                   id=\"userRole\"\n                   minWidth={{ md: \"150px\" }}\n                   maxWidth={{ lg: \"200px\" }}\n                   placeholder=\"권한\"\n                   {...register(\"userRole\")}\n                 />\n                 <CodeSelect\n                   codes={[\n                     { code: \"Y\", name: \"사용\" },\n                     { code: \"N\", name: \"미사용\" },\n                   ]}\n                   flex={{ sm: 1 }}\n                   id=\"useYN\"\n                   maxWidth={{ lg: \"200px\" }}\n                   minWidth={{ md: \"150px\" }}\n                   placeholder=\"사용여부\"\n                   {...register(\"useYN\")}\n                 />\n                 <CodeSelect\n                   codes={searchTypeOption}\n                   flex={{ sm: 1 }}\n                   id=\"searchType\"\n                   maxWidth={{ lg: \"170px\" }}\n                   minWidth={{ md: \"130px\" }}\n                   placeholder=\"검색조건\"\n                   {...register(\"searchType\")}\n                 />\n                 <Input\n                   flex={{ md: 2 }}\n                   id=\"search\"\n                   maxWidth={{ lg: \"300px\" }}\n                   minWidth={{ md: \"200px\" }}\n                   placeholder=\"검색어\"\n                   {...register(\"search\")}\n                 />\n                 <Input\n                   disabled={isSearching}\n                   hidden\n                   id=\"searchButton\"\n                   type=\"submit\"\n                 />\n                 <Input\n                   hidden\n                   id=\"resetButton\"\n                   type=\"button\"\n                   onClick={handleResetButtonClick}\n                 />\n               </Flex>\n             </FormControl>\n           </Box>\n         </Flex>\n       );\n     }\n     ```\n\n     1. 리액트 훅: 선언 명을 기준, 알파벳 순으로 정렬합니다.\n     2. 커스텀 훅: 선언 명을 기준, 알파벳 순으로 정렬합니다.\n     3. useState: 첫 번째 상태변수를 기준, 알파벳 순으로 정렬합니다.\n     4. function: 선언 명을 기준, 알파벳 순으로 정렬합니다.\n     5. useEffect\n     6. watch 함수\n\n  5. defaultProps\n\n     ```jsx\n     SearchPanel.defaultProps = defaultProps;\n     ```\n\n  6. export default\n\n     ```jsx\n     export default SearchPanel;\n     ```\n\n### 2.8. 에러 처리\n\n애플리케이션에서 발생하는 에러를 적절히 처리하는 것은 안정성과 예외 상황에 대한 대응력을 향상시킵니다. 아래는 에러 처리에 대한 가이드라인입니다.\n\n1. 예외 처리: 예외 상황이 발생할 수 있는 코드 블록에는 적절한 예외 처리를 구현합니다. 이는 try-catch 문을 사용하여 예외를 캐치하고, 적절한 로그 메시지를 출력하거나 사용자에게 에러 메시지를 표시하는 등의 처리를 수행합니다.\n2. 에러 핸들링: 애플리케이션의 최상위 수준에서 에러 핸들링을 구현합니다. 이는 예상치 못한 예외 상황이 발생했을 때 알림을 표시하고, 사용자에게 적절한 안내를 제공하는 등의 처리를 수행합니다.\n3. 로깅: 에러 발생 시 로그를 기록하고 추적 가능한 정보를 포함시킵니다. 이는 디버깅과 문제 해결에 도움을 줄 수 있습니다.\n4. 사용자 피드백: 에러 발생 시 사용자에게 적절한 피드백을 제공합니다. 이는 사용자가 문제 상황을 이해하고 대처할 수 있도록 도움을 줄 수 있습니다.\n5. 예외 처리 모듈: 애플리케이션에서 공통적으로 발생하는 예외 상황에 대한 처리를 모듈화하여 재사용성을 높일 수 있습니다.\n\n애플리케이션에서 발생할 수 있는 예외 상황을 사전에 고려하고, 적절한 에러 처리를 구현하여 안정성과 사용자 경험을 개선하는 것이 좋습니다.\n\n## 3. 프로젝트 구조\n\n### 3.1. 파일 및 폴더 구조\n\n```jsx\n- `package`: 프로젝트의 루트 디렉토리\n    - `app`: 애플리케이션의 소스 코드와 관련된 디렉토리\n        - `node_modules`: 프로젝트의 의존성 패키지들이 설치되는 디렉토리\n        - `public`: 정적 파일이 위치하는 디렉토리\n        - `src`: 소스 코드가 위치하는 디렉토리입니다.\n            - `api`: 서버 API와 통신하는 코드가 위치하는 디렉토리입니다.\n            - `assets`: 애플리케이션에서 사용되는 정적 리소스(이미지, 아이콘 등)가 위치\n            - `components`: 재사용 가능한 React 컴포넌트들이 위치하는 디렉토리\n            - `features`: 애플리케이션의 기능별로 구성된 모듈이 위치하는 디렉토리\n            - `libs`: 애플리케이션에서 사용되는 유틸리티 함수, 헬퍼 클래스 등이 위치\n            - `redux`: 리덕스의 리듀서, 액션, 미들웨어 등이 포함됩니다.\n            - `routes`: 라우팅과 관련된 코드가 위치하는 디렉토리입니다.\n            - `type`: 타입 정의 파일이 위치하는 디렉토리입니다.\n            - `App.css`: 애플리케이션 전체에 적용되는 CSS 스타일을 정의\n            - `App.test.tsx`: 애플리케이션의 테스트 코드가 위치하는 파일\n            - `index.css`: index.html 파일에서 사용되는 전역 CSS 스타일을 정의하는 파일\n            - `index.tsx`: React DOM 렌더링을 수행하는 코드가 이 파일에 포함됩니다.\n            - `react-app-env.d.ts`: Create React App에 의해 자동 생성되는 TypeScript 환경 설정 파일\n            - `reportWebVitals.ts`: 웹 애플리케이션의 성능 측정을 위한 코드가 위치하는 파일\n            - `setupProxy.js`: 개발 환경에서 프록시 설정을 위한 파일, 개발 서버와 API 서버 간의 통신을 프록시하는데 사용됩니다.\n            - `setupTest.ts`: 테스트 환경 설정을 위한 파일\n            - `theme.ts`: 애플리케이션의 테마 설정을 관리하는 파일\n    - `common`: 재사용되는 코드나 모듈들을 관리하는 디렉토리\n        - `dist`: 재사용되는 코드의 빌드 결과물이 위치하는 디렉토리\n        - `src`: 재사용되는 코드의 소스 파일들이 위치하는 디렉토리\n        - `package.json`: 재사용되는 코드의 의존성 패키지들을 관리하는 파일\n        - `tsconfig.json`: 재사용되는 코드의 TypeScript 환경 설정 파일\n```\n\n### 3.2. 모듈화와 컴포넌트 구성\n\n모듈화와 컴포넌트 구성은 코드의 재사용성과 유지보수성을 높이는 중요한 요소입니다. 아래는 모듈화와 컴포넌트 구성에 대한 가이드라인입니다.\n\n1. 모듈화:\n   - 기능 단위로 모듈을 분리하여 개발합니다. 각 모듈은 특정 기능을 수행하도록 설계되며, 관련된 코드와 리소스를 포함해야 합니다.\n   - 모듈 간의 의존성을 최소화하고, 각 모듈이 독립적으로 작동할 수 있도록 설계합니다. 이는 모듈 간의 결합도를 낮추고 유연성을 높일 수 있습니다.\n   - 모듈의 인터페이스를 명확하게 정의하고, 다른 모듈에서 재사용할 수 있는 API를 제공합니다.\n   - 모듈의 구현을 추상화하고, 내부 구현의 변경에 유연하게 대처할 수 있도록 설계합니다.\n2. 컴포넌트 구성:\n   - 컴포넌트는 UI 요소의 재사용 가능한 조합입니다. 비슷한 동작을 하는 UI 요소들을 하나의 컴포넌트로 추상화하고, 필요에 따라 다양한 속성을 통해 재사용할 수 있도록 설계합니다.\n   - 컴포넌트는 단일 책임 원칙을 준수하고, 가능한 한 작고 재사용 가능한 형태로 구성합니다. 이는 컴포넌트의 이해와 유지보수를 용이하게 합니다.\n   - 컴포넌트 간의 계층 구조를 구성하여, 복잡한 UI를 단순화하고 관리 가능한 단위로 분할합니다. 이는 코드의 가독성과 유지보수성을 향상시킵니다.\n   - 컴포넌트의 인터페이스를 명확하게 정의하고, 다른 컴포넌트와의 상호작용을 규정합니다.\n   - 컴포넌트 간의 상태 공유를 최소화하고, 필요한 데이터는 프로퍼티로 전달하여 컴포넌트 간의 독립성을 유지합니다.\n\n모듈화와 컴포넌트 구성은 코드의 구조를 개선하고, 재사용 가능한 코드의 양을 늘리는데 중요한 역할을 합니다. 적절한 모듈화와 컴포넌트 구성을 통해 개발 생산성과 코드 품질을 향상시킬 수 있습니다.\n\n### 3.3. 상태 관리\n\n상태 관리는 애플리케이션에서 데이터의 상태를 효과적으로 관리하는 것을 의미합니다. 아래는 상태 관리에 대한 가이드라인입니다.\n\n1. 단일 소스로 상태 관리하기:\n   - 애플리케이션의 모든 상태를 단일한 곳에서 관리하는 것이 중요합니다. 이를 통해 상태의 일관성을 유지하고, 데이터의 중복을 피할 수 있습니다.\n   - 상태 관리 라이브러리인 Redux 사용하여 상태를 중앙 집중화합니다.\n2. 상태의 불변성 유지:\n   - 상태는 불변성을 유지해야 합니다. 이는 상태를 직접 수정하지 않고 새로운 상태를 생성하여 업데이트하는 방식으로 작업해야 함을 의미합니다.\n3. 컴포넌트와 상태의 연결:\n   - 상태 관리 라이브러리를 활용하면 컴포넌트와 상태를 쉽게 연결할 수 있습니다. 이를 통해 상태의 변경을 자동으로 감지하고 컴포넌트를 업데이트할 수 있습니다.\n   - React의 Context API, ReactQuery 등을 활용하여 컴포넌트와 상태를 연결하고 패칭합니다.\n4. 비동기 상태 관리:\n   - 비동기 작업과 관련된 상태를 효과적으로 관리해야 합니다. API 호출, 비동기 데이터 로딩 등의 작업을 처리하는데 있어서 상태 관리 라이브러리의 비동기 처리 기능을 활용할 수 있습니다.\n   - Redux-Thunk를 사용하여 비동기 작업을 처리합니다.\n\n### 3.4. 라우팅\n\n라우팅은 사용자가 애플리케이션 내에서 다른 페이지 또는 뷰로 이동할 수 있는 기능을 제공하는 것입니다. 아래는 라우팅에 대한 가이드라인입니다.\n\n1. 라우팅 라이브러리 선택:\n   - React 애플리케이션에서 라우팅을 구현하기 위해 React Router 라우팅 라이브러리를 사용합니다.\n2. 라우팅 구성:\n   - 라우팅은 URL 경로와 해당 경로에 연결된 컴포넌트를 매핑하는 방식으로 구성됩니다.\n   - 라우터 컴포넌트를 사용하여 URL 경로와 컴포넌트를 매핑하고, 필요에 따라 중첩된 라우트와 파라미터를 처리할 수 있습니다.\n3. 네비게이션:\n   - 사용자가 다른 페이지로 이동할 수 있도록 네비게이션 기능을 구현합니다.\n   - useNavigate와 react-router-dom의 Navigate를 사용하여 라우터를 조작하여 네비게이션을 처리합니다.\n4. 보안과 권한 관리:\n   - 라우팅 시 보안 및 권한 관리가 필요한 경우, 인증 여부를 확인하고 접근 권한을 제어합니다.\n     - AppLayout: 토큰인증이 요구되는 접근 영역\n     - NonAuthenticationLayout: 비인증 상태 접근 영역\n   - 보호된 라우트, 권한 검사 및 리다이렉션과 같은 기능을 구현하여 보안과 권한 관리를 처리할 수 있습니다.\n\n라우팅은 사용자 경험을 향상시키고, 애플리케이션 내의 다양한 기능과 페이지 간의 이동을 가능하게 합니다. 적절한 라우팅 구현은 사용자의 효율성과 편의성을 높이는 데 중요한 역할을 합니다.\n\n## 4. 리소스 관리\n\n### 4.1. 이미지 및 아이콘\n\n이미지 및 아이콘은 애플리케이션에서 시각적인 요소를 추가하고 사용자 경험을 향상시키는 데 중요한 역할을 합니다. 아래는 이미지 및 아이콘 사용에 대한 가이드라인입니다.\n\n1. 이미지 사용:\n   - 애플리케이션에서 이미지를 사용하여 콘텐츠를 시각적으로 표현할 수 있습니다.\n   - 이미지를 삽입할 때는 최적화된 이미지를 사용하여 로딩 속도를 개선하고, 반응형 디자인에 맞게 이미지 크기를 조정해야 합니다.\n   - 이미지에 대체 텍스트를 제공하여 시각 장애인이나 이미지 로딩에 실패한 경우에도 콘텐츠를 이해할 수 있도록 해야 합니다.\n2. 아이콘 사용:\n   - 아이콘은 작고 간결한 그래픽 요소로서 애플리케이션에서 기능이나 상태를 시각적으로 나타내는 데 유용합니다.\n   - 아이콘 라이브러리로 Font Awesome를 사용합니다.\n   - 아이콘은 의미를 명확하게 전달해야 하므로, 사용 시 해당 아이콘의 의미와 사용 범위를 이해하고 적절하게 활용해야 합니다.\n3. 이미지 및 아이콘 관리:\n   - 이미지 및 아이콘은 프로젝트의 assets 디렉토리에서 관리됩니다.\n\n### 4.2. 스타일시트.\n\n스타일시트는 애플리케이션의 외관과 레이아웃을 결정하는 중요한 요소입니다. Chakra UI와 같은 스타일시트 라이브러리를 사용하면 일관된 디자인 시스템을 구축하고 UI 개발을 효율적으로 진행할 수 있습니다. 아래는 Chakra UI를 사용한 스타일시트 작성에 대한 가이드라인입니다.\n\n1. Chakra UI:\n   - 프로젝트에 Chakra UI가 설치되어있습니다.\n   - ChakraProvider는 애플리케이션의 최상위에 Chakra UI가 적용되어 있습니다.\n2. 컴포넌트 스타일링:\n   - Chakra UI는 다양한 사전 정의된 컴포넌트와 스타일 프로퍼티를 제공합니다. 이를 활용하여 컴포넌트를 스타일링할 수 있습니다.\n   - 스타일 프로퍼티를 사용하여 컴포넌트의 스타일을 변경하거나 커스터마이징할 수 있습니다.\n   - Chakra UI의 ThemeProvider를 사용하여 테마 설정을 관리하고 커스텀 테마를 적용할 수 있습니다.\n3. 반응형 디자인:\n   - Chakra UI는 반응형 디자인을 지원하여 다양한 장치와 화면 크기에 대응할 수 있습니다.\n   - \"@chakra-ui/media-query\" 모듈을 사용하여 미디어 쿼리를 활용할 수 있습니다. 이를 활용하여 특정 화면 크기에 대한 스타일 조정합니다.\n4. 커스텀 컴포넌트:\n   - 필요에 따라 Chakra UI의 컴포넌트를 확장하여 커스텀 컴포넌트를 생성합니다.\n   - 커스텀 컴포넌트를 생성하여 재사용성과 코드 유지 보수성을 향상킵니다.\n\nChakra UI를 사용하여 스타일시트를 작성하면 일관된 디자인 시스템을 구축하고 개발 생산성을 높일 수 있습니다. 적절하게 활용하여 사용자 인터페이스를 구성하고 디자인 요소를 일관되게 관리해야 합니다.\n\n### 4.3. 외부 라이브러리와 의존성 관리\n\n모던한 프론트엔드 애플리케이션 개발에는 종종 외부 라이브러리와 의존성이 필요합니다. 이러한 라이브러리와 의존성을 효율적으로 관리하고 활용하는 것이 중요합니다. 아래는 몇 가지 널리 사용되는 라이브러리와 의존성에 대한 간단한 소개입니다:\n\n1. emotion:\n   - emotion은 CSS-in-JS 라이브러리로, JavaScript 코드 내에서 CSS 스타일을 작성할 수 있습니다. 컴포넌트 단위로 스타일을 캡슐화하여 유지보수 및 재사용성을 높일 수 있습니다.\n2. reduxjs:\n   - reduxjs는 상태 관리 라이브러리로, 애플리케이션의 상태를 중앙에서 관리하고 예측 가능한 상태 변화를 제공합니다. redux를 사용하여 복잡한 애플리케이션 상태를 효과적으로 관리할 수 있습니다.\n3. ag-grid-react:\n   - ag-grid-react는 강력한 그리드 컴포넌트 라이브러리로, 테이블 형태의 데이터를 표시하고 조작할 수 있습니다. 유연한 기능과 다양한 커스터마이징 옵션을 제공하여 데이터 그리드를 구축할 수 있습니다.\n4. axios:\n   - axios는 HTTP 클라이언트 라이브러리로, 비동기적으로 서버와 데이터 통신을 할 수 있습니다. REST API와의 상호작용이나 데이터 요청 처리에 유용합니다.\n5. date-fns:\n   - date-fns는 JavaScript 날짜 유틸리티 라이브러리로, 날짜와 시간 관련 작업을 쉽게 처리할 수 있습니다. 날짜 형식 변환, 날짜 계산, 로컬라이징 등 다양한 기능을 제공합니다.\n6. framer-motion:\n   - framer-motion은 React용 모션 및 애니메이션 라이브러리로, 화면 전환 및 요소 애니메이션을 부드럽게 구현할 수 있습니다. 유연한 애니메이션 효과와 상호작용을 제공합니다.\n7. lodash:\n   - lodash는 JavaScript 유틸리티 라이브러리로, 다양한 유용한 함수들을 제공합니다. 배열, 객체, 함수 등을 다루는 다양한 작업에 활용할 수 있습니다.\n8. quill:\n   - quill은 리치 텍스트 에디터 라이브러리로, 사용자가 서식 있는 텍스트를 작성하고 편집할 수 있는 기능을 제공합니다. 이미지, 표, 링크 등을 삽입할 수 있는 다양한 기능을 제공합니다.\n9. react-datepicker:\n   - react-datepicker는 React용 날짜 선택 컴포넌트 라이브러리로, 사용자가 날짜를 선택하고 입력할 수 있는 기능을 제공합니다. 다양한 날짜 형식과 옵션을 설정할 수 있습니다.\n10. web-vitals:\n    - web-vitals는 웹 애플리케이션의 성능 지표를 측정하는 라이브러리로, 사용자 경험을 평가하고 개선하는 데 도움을 줍니다. 측정된 지표를 통해 성능 최적화에 대한 통찰력을 얻을 수 있습니다.\n11. xlsx:\n    - xlsx는 Excel 파일을 다루는 라이브러리로, 데이터를 읽고 쓰는 기능을 제공합니다. Excel 파일 형식을 다루는 다양한 작업을 수행할 수 있습니다.\n12. monaco-editor:\n    - monaco-editor는 웹 기반의 텍스트 편집기 라이브러리로, 문법 강조, 자동 완성, 신택스 검증 등 다양한 기능을 제공합니다. 개발자용 IDE나 코드 에디터에 적용할 수 있습니다.\n\n이러한 외부 라이브러리와 의존성을 적절하게 활용하여 개발 생산성을 향상시키고 애플리케이션에 필요한 기능을 구현할 수 있습니다. 의존성 관리와 버전 업데이트에 주의하여 안정성과 호환성을 유지하는 것이 중요합니다. 6. framer-motion:\n\n- framer-motion은 React용 모션 및 애니메이션 라이브러리로, 화면 전환 및 요소 애니메이션을 부드럽게 구현할 수 있습니다. 유연한 애니메이션 효과와 상호작용을 제공합니다.\n\n7. lodash:\n   - lodash는 JavaScript 유틸리티 라이브러리로, 다양한 유용한 함수들을 제공합니다. 배열, 객체, 함수 등을 다루는 다양한 작업에 활용할 수 있습니다.\n8. quill:\n   - quill은 리치 텍스트 에디터 라이브러리로, 사용자가 서식 있는 텍스트를 작성하고 편집할 수 있는 기능을 제공합니다. 이미지, 표, 링크 등을 삽입할 수 있는 다양한 기능을 제공합니다.\n9. react-datepicker:\n   - react-datepicker는 React용 날짜 선택 컴포넌트 라이브러리로, 사용자가 날짜를 선택하고 입력할 수 있는 기능을 제공합니다. 다양한 날짜 형식과 옵션을 설정할 수 있습니다.\n10. web-vitals:\n    - web-vitals는 웹 애플리케이션의 성능 지표를 측정하는 라이브러리로, 사용자 경험을 평가하고 개선하는 데 도움을 줍니다. 측정된 지표를 통해 성능 최적화에 대한 통찰력을 얻을 수 있습니다.\n11. xlsx:\n    - xlsx는 Excel 파일을 다루는 라이브러리로, 데이터를 읽고 쓰는 기능을 제공합니다. Excel 파일 형식을 다루는 다양한 작업을 수행할 수 있습니다.\n12. monaco-editor:\n    - monaco-editor는 웹 기반의 텍스트 편집기 라이브러리로, 문법 강조, 자동 완성, 신택스 검증 등 다양한 기능을 제공합니다. 개발자용 IDE나 코드 에디터에 적용할 수 있습니다.\n\n이러한 외부 라이브러리와 의존성을 적절하게 활용하여 개발 생산성을 향상시키고 애플리케이션에 필요한 기능을 구현할 수 있습니다. 의존성 관리와 버전 업데이트에 주의하여 안정성과 호환성을 유지하는 것이 중요합니다.\n","category":"frontend","date":"2024-03-20","tags":["Convention","Document"],"thumbnail":"/images/convention.png"},{"id":"cursor_ai","title":"Cursor AI","description":"Cursor AI 사용법","content":"<hr>\n<p>이번에 작성한 글은 Cursor를 빨리 익히기 위해 정보들을 모아봤습니다.</p>\n<p>알아두면 진짜 좋은 기능들도 있으니 한번 공부해보시는걸 추천합니다.</p>\n<hr>\n<h2><strong>#1 VSCode 연동</strong></h2>\n<p>Cursor는 VSCode를 포크 떠서 만든 IDE기 떄문에 기존에 VSCode에서 사용하던 확장들을 가져올 수 있습니다.</p>\n<p>Cursor Settings > General > Account</p>\n<p>로 가셔서 설정할 수 있습니다.</p>\n<p><strong>Cursor Settings를 못찾겠다면 Ctrl + Shift + J를 누르셔서 여시면 됩니다.</strong></p>\n<h2><strong>#2 주요 커맨드 ( 단축키 )</strong></h2>\n<p>Cursor에서는 아래 3가지 기능을 단축키로 외워두시면 80퍼센트 알게된거라 보시면 됩니다.</p>\n<p><strong>1. Tab</strong></p>\n<p>에디터에서 약 1초간 가만히 있으면 Cursor Copilot++이 AI로 <strong>코드를 자동완성</strong> 해줍니다.</p>\n<p><img src=\"https://blog.kakaocdn.net/dn/cdDb18/btsJ4eATVwU/hvckbgbLoex5JEeOo5UKG0/img.png\" alt=\"1\"></p>\n<p>코드 자동 예측해서 완성</p>\n<p><img src=\"https://blog.kakaocdn.net/dn/cRoxgk/btsJ5fTbJeO/s6G0KkwOoU6ZsaJCzPkkn0/img.png\" alt=\"2\"></p>\n<p>다른 줄의 패턴에 따라 자동 완성\n다른 줄의 패턴에 따라 자동 완성</p>\n<p><strong>2. Ctrl + K</strong></p>\n<p>Ctrl + K를 사용하면 AI로 <strong>바로바로 코드를 편집</strong>하고 작성할 수 있습니다.</p>\n<p>이걸 쓰는 이유는 특정 범위 또는 줄만 바로 프롬포트로 수정하거나 질문 가능하기때문입니다.</p>\n<p>완전히 새로운 코드를 생성하려면 아무 것도 선택하지 않고 Ctrl K만 입력하면 됩니다.</p>\n<p>@Codebase, @Docs, @Web 등 여러 가지 심볼 설정을 똑같이 사용가능합니다.</p>\n<p>심볼에 관해선 아래 #3 에 설명</p>\n<p><img src=\"https://blog.kakaocdn.net/dn/GTFbL/btsJ3XMKOBh/ZJRPnbzrqi0EbExZGmQjgK/img.png\" alt=\"3\"></p>\n<p>코드에 Ctrl + K를 사용하면 미니 팝업이 뜹니다.</p>\n<p><img src=\"https://blog.kakaocdn.net/dn/cEzQo2/btsJ6cOZUZc/ORWKTYcniTMSg7xunqKN01/img.png\" alt=\"4\"></p>\n<p>코드를 생성하거나 수정요청할 수 있으며 바뀌는걸 Ctrl + shift + Y로 수락, Ctrl + N로 거부</p>\n<p><img src=\"https://blog.kakaocdn.net/dn/bH7nMH/btsJ6fZfVhl/auMcvlKPV3Zbu0sKPHHk71/img.png\" alt=\"5\"></p>\n<p>미니팝업에 질문을 쓰고 Alt + Enter를 입력하면 바로 해당 코드에 질문 가능합니다</p>\n<p><img src=\"https://blog.kakaocdn.net/dn/HHXcp/btsJ303JNcn/GPk9Jue2AqkAOMbjiUq04k/img.png\" alt=\"6\"></p>\n<p>또한 VSCode 내부 CMD 커맨드 터미널에도 사용 가능합니다</p>\n<p><strong>3. Ctrl + L</strong></p>\n<p>Ctrl + L를 사용하면 에디터 화면 오른쪽에 LLM과 <strong>Chat을 할 수 있는 탭</strong>이 열립니다.</p>\n<p>Chat을 통해 현재 열린 코드 파일을 보는 AI와 대화할 수 있습니다.</p>\n<p>채팅에서는 항상 현재 파일과 커서를 볼 수 있으므로 \"지금 코드에 버그가 있나요?\"와 같은 질문을 할 수 있습니다.</p>\n<p>@Codebase, @Docs, @Web 등 여러 가지 심볼 설정을 똑같이 사용가능합니다.</p>\n<p>심볼에 관해선 아래 #3 에 설명</p>\n<p><img src=\"https://blog.kakaocdn.net/dn/cWeTgN/btsJ6V61F8p/QHZY7X7fSTtvreM8Wfp2O0/img.png\" alt=\"7\"></p>\n<p>Ctrl+Shift+L 또는 \"@\"을 사용하여 특정 코드 블록을 컨텍스트에 추가할 수 있습니다.</p>\n<p><img src=\"https://blog.kakaocdn.net/dn/Td96H/btsJ6pggIG3/QEJHTBjc8Vd5N97QhZqOdk/img.png\" alt=\"8\"></p>\n<p>Ctrl+Enter를 눌러 전체 코드베이스와 채팅할 수 있습니다. 스캔에 조금 시간 걸립니다.</p>\n<hr>\n<h2><strong>#3 심볼 @</strong></h2>\n<p>Cursor에는 Chat이나 미니 프롬프트에 챗을 사용할 때 심볼로 검색 기능을 바꿀 수 있습니다.</p>\n<p>\"@\" 기호를 입력시 여러 검색 기능을 볼 수 있으며 원하는 검색 방식을 선택할 수 있습니다.</p>\n<p><strong>@Codebase</strong></p>\n<p><img src=\"https://blog.kakaocdn.net/dn/bkYI3Z/btsJ6H2hFeI/MPnqVe6Khe0JnrvTEYutTK/img.png\" alt=\"9\"></p>\n<p>@Codebase 를 입력시 전체 코드베이스를 스캔하여 답변을 합니다.</p>\n<p>프로젝트 전체적으로 훑어보고 싶으시거나 파일 전체를 대상으로 질문하고 싶을 때 사용을 추천합니다.</p>\n<p><strong>@Docs</strong></p>\n<p><img src=\"https://blog.kakaocdn.net/dn/cUcSsm/btsJ6jm0xDQ/GCIQq5JQGnSF3WkHaxCqc0/img.png\" alt=\"10\"></p>\n<p>@Docs 탭</p>\n<p><img src=\"https://blog.kakaocdn.net/dn/sMKQt/btsJ3Y5YZT1/jCKqjgW61O1y5U2tqKDgoK/img.png\" alt=\"11\"></p>\n<p>Docs 탭을 선택 후 뜨는 입력창, 원하시는 문서 링크를 넣으시고 Confirm 눌러주세요</p>\n<p><img src=\"https://blog.kakaocdn.net/dn/kCIHe/btsJ418wVBx/3Jgmyu3bIBLvgBMVZ8O9H1/img.png\" alt=\"12\"></p>\n<p>문서를 제대로 받아온 모습</p>\n<p>@Docs 를 입력시 인기 있는 라이브러리를 참조하거나 @Docs → Add new doc 를 사용하여</p>\n<p>원하시는 문서의 웹사이트 링크를 입력하여 참조가능합니다. 참조한 문서는 계속 사용 가능합니다.</p>\n<p>참조한 문서를 토대로 AI가 답변을 해줍니다.</p>\n<p><strong>@Web</strong></p>\n<p><img src=\"https://blog.kakaocdn.net/dn/FRGN9/btsJ5BIhtqh/2wFJe1MGlngfokGK8R0LA0/img.png\" alt=\"13\"></p>\n<p>@Web 를 입력시 AI가 인터넷에서 최신 정보를 검색하여 요약한 내용을 바탕으로 답변을 해줍니다.</p>\n<p>이렇게 심볼을 상황에 맞게 잘 선택하여 써주시면 됩니다.</p>\n<p>근데 @Web은 써보니까 그냥 제가 검색하는게 나을것 같은 성능이네요.</p>\n<hr>\n<h2><strong>#4 AI 모델 추천, 어떤 모델을 써야할까?</strong></h2>\n<p><img src=\"https://blog.kakaocdn.net/dn/dHnTx9/btsJ5B9lOeZ/jWocrv6PoagJEpkKuqLOG1/img.png\" alt=\"14\"></p>\n<p>2024.10.15 날짜 기준으로 Hobby(기본) 요금제를 사용하고 있는 제 화면에는 이렇게 모델들이 있습니다.</p>\n<p>상황에 따라 다른 모델을 쓰는것을 추천합니다.</p>\n<p><strong>일반적인 상황</strong></p>\n<p><strong>claude-3.5-sonnet</strong>이 추론 능력이라던지 일반적인 상황에선 쓰기 가장 좋았습니다.</p>\n<p><strong>복잡한 코드나 에러 분석해야할 때</strong></p>\n<p><strong>o1-mini</strong>가 가장 전문적인 것 같아 쓰기 좋았습니다.</p>\n<p>참고 : 모델 교체할 때는 ctrl + / 키를 누르시면 단축키로 바로 모델 교체 가능합니다.</p>\n<p>모델 교체 메뉴를 바로 여는 단축키는 ctrl + alt + / 키입니다.</p>\n<p><img src=\"https://blog.kakaocdn.net/dn/yFAmD/btsJ4da1zkb/4Klu0kxgIi5E6KhgyWKVk0/img.png\" alt=\"15\"></p>\n<p>이외에도 따로 쓰고 싶으신 모델은 Cursor Settings 설정에 가셔서 토글하실 수 있고 원하는 모델을 추가할 수 있습니다.</p>\n<hr>\n<h2><strong>#5 AI 규칙 설정</strong></h2>\n<p><img src=\"https://blog.kakaocdn.net/dn/dBWkCU/btsJ4fNc1KA/Xm3nE1yAqFcrX09RiauX9k/img.png\" alt=\"16\"></p>\n<p>Cursor Settings -> General -> Rules for AI</p>\n<p>Cursor Settings(Ctrl + Shift + J)를 들어가보시면 AI 규칙을 설정할 수 있습니다.</p>\n<p>그냥 써도 기본으로 최대한 한국어로 답변하라는 규칙이 설정되어있을겁니다.</p>\n<p>이걸 조금 더 가공해서 더 퀄리티 높은 답변을 할 수 있도록하는 규칙을 공유해드리겠습니다.</p>\n<p><strong>닫기</strong></p>\n<p>you are an expert AI programming assistant in VSCode that primarily focuses on producing clear, readable code.</p>\n<p>You are thoughtful, give nuanced answers, and are brilliant at reasoning.</p>\n<p>You carefully provide accurate, factual, and thoughtful answers, and you are a genius at reasoning.</p>\n<p>1. Follow the user's requirements carefully and precisely.</p>\n<p>2. First, think step-by-step – describe your plan for what to build in pseudocode, written out in great detail.</p>\n<p>3. Confirm, then write the code!</p>\n<p>4. Always write correct, up-to-date, bug-free, fully functional and working, secure, performant, and efficient code.</p>\n<p>5. Focus on <strong>readability</strong> over performance.</p>\n<p>6. Fully implement all requested functionality.</p>\n<p>7. Leave <strong>NO</strong> to-dos, placeholders, or missing pieces.</p>\n<p>8. Ensure the code is complete! Thoroughly verify the final version.</p>\n<p>9. Include all required <strong>imports</strong>, and ensure proper naming of key components.</p>\n<p>10. Be concise. Minimize any unnecessary explanations.</p>\n<p>11. If you think there might not be a correct answer, say so. If you do not know the answer, admit it instead of guessing.</p>\n<p>12. Always provide concise answers.</p>\n<p>13. Please answer in Korean</p>\n<p>혹시나 현재 사용하고 계신 언어에 맞게 또는 원하는 플랫폼에 맞는 AI 답변을 원할 경우</p>\n<p>아래 링크에서 다른 규칙도 찾아보시는걸 추천 드립니다.</p>\n<p>https://cursor.directory/</p>\n<p><a href=\"https://cursor.directory/\"><strong>Cursor Directory</strong>\nFind the best cursor rules for your framework and language\ncursor.directory</a></p>\n<hr>\n<h2><strong>#6 노트패드 기능 (베타)</strong></h2>\n<p>Cursor에서도 노트패드를 관리할 수 있습니다.</p>\n<p>Ctrl + i 키 또는 맥에선 Cmd + i 키를 누르셔서 Composer 탭을 열어주신 뒤(아마 작을겁니다)</p>\n<p><img src=\"https://blog.kakaocdn.net/dn/bYjCvy/btsJ4KlQRZ4/SBt6wNNBs3KpFbiiO8okqk/img.png\" alt=\"17\"></p>\n<p>오른쪽 상단에 Open Control Panel 버튼을 눌러주시면 노트패드가 열립니다.</p>\n<p><img src=\"https://blog.kakaocdn.net/dn/cHyWbo/btsJ5ovExHi/hQT95gHW0IwY0hLYH3HKM1/img.png\" alt=\"18\"></p>\n<p>노트패드창에서 왼쪽탭 상단에 더하기 버튼이 있을텐데 이 버튼을 눌러서 노트 하나 생성합시다.</p>\n<p><img src=\"https://blog.kakaocdn.net/dn/QC5AR/btsJ3Z3P8F5/rTCtSsUwyDVa5aSqluyxsk/img.png\" alt=\"19\"></p>\n<p>노트 내용에 아무거나 쓰신 뒤 Ctrl + L 키를 눌러 프롬프트에 들고 갑시다.</p>\n<p><img src=\"https://blog.kakaocdn.net/dn/bKlwOE/btsJ4YYtlhY/uHMukld8JLY9qIvuBqQlKK/img.png\" alt=\"20\"></p>\n<p>이런식으로 방금 만든 노트패드가 @로 추적이 가능합니다.</p>\n<p><img src=\"https://blog.kakaocdn.net/dn/c6cglp/btsJ5CNZZlJ/8k4TMMZSMR25xODbkCT1K0/img.png\" alt=\"21\"></p>\n<p>노트패드를 프롬프트에 포함시켜 이런식으로 결과물을 받아올 수도 있긴하지만</p>\n<p>노트패드 작성시에 AI 기능이 있었다면 더 좋지 않을까 싶네요 아직 베타니까 기다려봅시다.</p>\n<hr>\n<h2><strong>#7 프로젝트 5분만에 분석하는 법</strong></h2>\n<p>Cursor를 이용해 5분 만에 프로젝트 구조를 파악하는 방법을 알려드리겠습니다.</p>\n<blockquote>\n<ol>\n<li>Ctrl + L 을 눌러 Cursor 채팅 패널을 엽니다.</li>\n</ol>\n<p><a href=\"http://www.mermaidchart.com/\">http://www.mermaidchart.com</a></p>\n</blockquote>\n<p>https://kimyir.tistory.com/97</p>\n<p><a href=\"https://kimyir.tistory.com/97\"><strong>Cursor로 5분만에 프로젝트 분석하기</strong>\n프로젝트 5분만에 분석하는 법 Cursor를 이용해 5분 만에 프로젝트 구조를 파악하는 방법을 알려드리겠습니다. 1. Ctrl + L 을 눌러 Cursor 채팅 패널을 엽니다. 2. \"Normal chat\"에서 \"Long Co\nkimyir.tistory.com</a></p>\n<hr>\n<p>이상 Cursor의 기본 사용 방법과 꿀팁을 정리해보았습니다.</p>\n<p>VSCode를 바탕으로 만들어서 그런지 접근하기 쉬웠고 쓰기도 편한 것 같습니다.</p>\n<p>물론 기능이 많은 만큼 IDE 속도가 느려진 것 같지만 능률을 위해서라면 그래도 쓸 것 같네요.</p>\n<p>내 코드가 혹시나 AI가 학습하지 않을까 걱정되신다면</p>\n<p>Cursor Settings -> General -> Privacy mode 탭에 가셔서 enabled로 설정해주시면 됩니다.</p>\n<p>코드가 외부에 유출안되지만 AI 답변 품질이 떨어질 순 있습니다.</p>\n<p><strong>번외) 다른 유용한 AI 추천</strong></p>\n<p>터미널 AI 도우미</p>\n<p>https://github.com/Aider-AI/aider</p>\n","plainContent":"\n---\n\n이번에 작성한 글은 Cursor를 빨리 익히기 위해 정보들을 모아봤습니다.\n\n알아두면 진짜 좋은 기능들도 있으니 한번 공부해보시는걸 추천합니다.\n\n---\n\n## **#1 VSCode 연동**\n\nCursor는 VSCode를 포크 떠서 만든 IDE기 떄문에 기존에 VSCode에서 사용하던 확장들을 가져올 수 있습니다.\n\nCursor Settings > General > Account\n\n로 가셔서 설정할 수 있습니다.\n\n**Cursor Settings를 못찾겠다면 Ctrl + Shift + J를 누르셔서 여시면 됩니다.**\n\n## **#2 주요 커맨드 ( 단축키 )**\n\nCursor에서는 아래 3가지 기능을 단축키로 외워두시면 80퍼센트 알게된거라 보시면 됩니다.\n\n**1. Tab**\n\n에디터에서 약 1초간 가만히 있으면 Cursor Copilot++이 AI로 **코드를 자동완성** 해줍니다.\n\n![1](https://blog.kakaocdn.net/dn/cdDb18/btsJ4eATVwU/hvckbgbLoex5JEeOo5UKG0/img.png)\n\n코드 자동 예측해서 완성\n\n![2](https://blog.kakaocdn.net/dn/cRoxgk/btsJ5fTbJeO/s6G0KkwOoU6ZsaJCzPkkn0/img.png)\n\n다른 줄의 패턴에 따라 자동 완성\n다른 줄의 패턴에 따라 자동 완성\n\n**2. Ctrl + K**\n\nCtrl + K를 사용하면 AI로 **바로바로 코드를 편집**하고 작성할 수 있습니다.\n\n이걸 쓰는 이유는 특정 범위 또는 줄만 바로 프롬포트로 수정하거나 질문 가능하기때문입니다.\n\n완전히 새로운 코드를 생성하려면 아무 것도 선택하지 않고 Ctrl K만 입력하면 됩니다.\n\n@Codebase, @Docs, @Web 등 여러 가지 심볼 설정을 똑같이 사용가능합니다.\n\n심볼에 관해선 아래 #3 에 설명\n\n![3](https://blog.kakaocdn.net/dn/GTFbL/btsJ3XMKOBh/ZJRPnbzrqi0EbExZGmQjgK/img.png)\n\n코드에 Ctrl + K를 사용하면 미니 팝업이 뜹니다.\n\n![4](https://blog.kakaocdn.net/dn/cEzQo2/btsJ6cOZUZc/ORWKTYcniTMSg7xunqKN01/img.png)\n\n코드를 생성하거나 수정요청할 수 있으며 바뀌는걸 Ctrl + shift + Y로 수락, Ctrl + N로 거부\n\n![5](https://blog.kakaocdn.net/dn/bH7nMH/btsJ6fZfVhl/auMcvlKPV3Zbu0sKPHHk71/img.png)\n\n미니팝업에 질문을 쓰고 Alt + Enter를 입력하면 바로 해당 코드에 질문 가능합니다\n\n![6](https://blog.kakaocdn.net/dn/HHXcp/btsJ303JNcn/GPk9Jue2AqkAOMbjiUq04k/img.png)\n\n또한 VSCode 내부 CMD 커맨드 터미널에도 사용 가능합니다\n\n**3. Ctrl + L**\n\nCtrl + L를 사용하면 에디터 화면 오른쪽에 LLM과 **Chat을 할 수 있는 탭**이 열립니다.\n\nChat을 통해 현재 열린 코드 파일을 보는 AI와 대화할 수 있습니다.\n\n채팅에서는 항상 현재 파일과 커서를 볼 수 있으므로 \"지금 코드에 버그가 있나요?\"와 같은 질문을 할 수 있습니다.\n\n@Codebase, @Docs, @Web 등 여러 가지 심볼 설정을 똑같이 사용가능합니다.\n\n심볼에 관해선 아래 #3 에 설명\n\n![7](https://blog.kakaocdn.net/dn/cWeTgN/btsJ6V61F8p/QHZY7X7fSTtvreM8Wfp2O0/img.png)\n\nCtrl+Shift+L 또는 \"@\"을 사용하여 특정 코드 블록을 컨텍스트에 추가할 수 있습니다.\n\n![8](https://blog.kakaocdn.net/dn/Td96H/btsJ6pggIG3/QEJHTBjc8Vd5N97QhZqOdk/img.png)\n\nCtrl+Enter를 눌러 전체 코드베이스와 채팅할 수 있습니다. 스캔에 조금 시간 걸립니다.\n\n---\n\n## **#3 심볼 @**\n\nCursor에는 Chat이나 미니 프롬프트에 챗을 사용할 때 심볼로 검색 기능을 바꿀 수 있습니다.\n\n\"@\" 기호를 입력시 여러 검색 기능을 볼 수 있으며 원하는 검색 방식을 선택할 수 있습니다.\n\n**@Codebase**\n\n![9](https://blog.kakaocdn.net/dn/bkYI3Z/btsJ6H2hFeI/MPnqVe6Khe0JnrvTEYutTK/img.png)\n\n@Codebase 를 입력시 전체 코드베이스를 스캔하여 답변을 합니다.\n\n프로젝트 전체적으로 훑어보고 싶으시거나 파일 전체를 대상으로 질문하고 싶을 때 사용을 추천합니다.\n\n**@Docs**\n\n![10](https://blog.kakaocdn.net/dn/cUcSsm/btsJ6jm0xDQ/GCIQq5JQGnSF3WkHaxCqc0/img.png)\n\n@Docs 탭\n\n![11](https://blog.kakaocdn.net/dn/sMKQt/btsJ3Y5YZT1/jCKqjgW61O1y5U2tqKDgoK/img.png)\n\nDocs 탭을 선택 후 뜨는 입력창, 원하시는 문서 링크를 넣으시고 Confirm 눌러주세요\n\n![12](https://blog.kakaocdn.net/dn/kCIHe/btsJ418wVBx/3Jgmyu3bIBLvgBMVZ8O9H1/img.png)\n\n문서를 제대로 받아온 모습\n\n@Docs 를 입력시 인기 있는 라이브러리를 참조하거나 @Docs → Add new doc 를 사용하여\n\n원하시는 문서의 웹사이트 링크를 입력하여 참조가능합니다. 참조한 문서는 계속 사용 가능합니다.\n\n참조한 문서를 토대로 AI가 답변을 해줍니다.\n\n**@Web**\n\n![13](https://blog.kakaocdn.net/dn/FRGN9/btsJ5BIhtqh/2wFJe1MGlngfokGK8R0LA0/img.png)\n\n@Web 를 입력시 AI가 인터넷에서 최신 정보를 검색하여 요약한 내용을 바탕으로 답변을 해줍니다.\n\n이렇게 심볼을 상황에 맞게 잘 선택하여 써주시면 됩니다.\n\n근데 @Web은 써보니까 그냥 제가 검색하는게 나을것 같은 성능이네요.\n\n---\n\n## **#4 AI 모델 추천, 어떤 모델을 써야할까?**\n\n![14](https://blog.kakaocdn.net/dn/dHnTx9/btsJ5B9lOeZ/jWocrv6PoagJEpkKuqLOG1/img.png)\n\n2024.10.15 날짜 기준으로 Hobby(기본) 요금제를 사용하고 있는 제 화면에는 이렇게 모델들이 있습니다.\n\n상황에 따라 다른 모델을 쓰는것을 추천합니다.\n\n**일반적인 상황**\n\n**claude-3.5-sonnet**이 추론 능력이라던지 일반적인 상황에선 쓰기 가장 좋았습니다.\n\n**복잡한 코드나 에러 분석해야할 때**\n\n**o1-mini**가 가장 전문적인 것 같아 쓰기 좋았습니다.\n\n참고 : 모델 교체할 때는 ctrl + / 키를 누르시면 단축키로 바로 모델 교체 가능합니다.\n\n모델 교체 메뉴를 바로 여는 단축키는 ctrl + alt + / 키입니다.\n\n![15](https://blog.kakaocdn.net/dn/yFAmD/btsJ4da1zkb/4Klu0kxgIi5E6KhgyWKVk0/img.png)\n\n이외에도 따로 쓰고 싶으신 모델은 Cursor Settings 설정에 가셔서 토글하실 수 있고 원하는 모델을 추가할 수 있습니다.\n\n---\n\n## **#5 AI 규칙 설정**\n\n![16](https://blog.kakaocdn.net/dn/dBWkCU/btsJ4fNc1KA/Xm3nE1yAqFcrX09RiauX9k/img.png)\n\nCursor Settings -> General -> Rules for AI\n\nCursor Settings(Ctrl + Shift + J)를 들어가보시면 AI 규칙을 설정할 수 있습니다.\n\n그냥 써도 기본으로 최대한 한국어로 답변하라는 규칙이 설정되어있을겁니다.\n\n이걸 조금 더 가공해서 더 퀄리티 높은 답변을 할 수 있도록하는 규칙을 공유해드리겠습니다.\n\n**닫기**\n\nyou are an expert AI programming assistant in VSCode that primarily focuses on producing clear, readable code.\n\nYou are thoughtful, give nuanced answers, and are brilliant at reasoning.\n\nYou carefully provide accurate, factual, and thoughtful answers, and you are a genius at reasoning.\n\n1. Follow the user's requirements carefully and precisely.\n\n2. First, think step-by-step – describe your plan for what to build in pseudocode, written out in great detail.\n\n3. Confirm, then write the code!\n\n4. Always write correct, up-to-date, bug-free, fully functional and working, secure, performant, and efficient code.\n\n5. Focus on **readability** over performance.\n\n6. Fully implement all requested functionality.\n\n7. Leave **NO** to-dos, placeholders, or missing pieces.\n\n8. Ensure the code is complete! Thoroughly verify the final version.\n\n9. Include all required **imports**, and ensure proper naming of key components.\n\n10. Be concise. Minimize any unnecessary explanations.\n\n11. If you think there might not be a correct answer, say so. If you do not know the answer, admit it instead of guessing.\n\n12. Always provide concise answers.\n\n13. Please answer in Korean\n\n혹시나 현재 사용하고 계신 언어에 맞게 또는 원하는 플랫폼에 맞는 AI 답변을 원할 경우\n\n아래 링크에서 다른 규칙도 찾아보시는걸 추천 드립니다.\n\nhttps://cursor.directory/\n\n[**Cursor Directory**\nFind the best cursor rules for your framework and language\ncursor.directory](https://cursor.directory/)\n\n---\n\n## **#6 노트패드 기능 (베타)**\n\nCursor에서도 노트패드를 관리할 수 있습니다.\n\nCtrl + i 키 또는 맥에선 Cmd + i 키를 누르셔서 Composer 탭을 열어주신 뒤(아마 작을겁니다)\n\n![17](https://blog.kakaocdn.net/dn/bYjCvy/btsJ4KlQRZ4/SBt6wNNBs3KpFbiiO8okqk/img.png)\n\n오른쪽 상단에 Open Control Panel 버튼을 눌러주시면 노트패드가 열립니다.\n\n![18](https://blog.kakaocdn.net/dn/cHyWbo/btsJ5ovExHi/hQT95gHW0IwY0hLYH3HKM1/img.png)\n\n노트패드창에서 왼쪽탭 상단에 더하기 버튼이 있을텐데 이 버튼을 눌러서 노트 하나 생성합시다.\n\n![19](https://blog.kakaocdn.net/dn/QC5AR/btsJ3Z3P8F5/rTCtSsUwyDVa5aSqluyxsk/img.png)\n\n노트 내용에 아무거나 쓰신 뒤 Ctrl + L 키를 눌러 프롬프트에 들고 갑시다.\n\n![20](https://blog.kakaocdn.net/dn/bKlwOE/btsJ4YYtlhY/uHMukld8JLY9qIvuBqQlKK/img.png)\n\n이런식으로 방금 만든 노트패드가 @로 추적이 가능합니다.\n\n![21](https://blog.kakaocdn.net/dn/c6cglp/btsJ5CNZZlJ/8k4TMMZSMR25xODbkCT1K0/img.png)\n\n노트패드를 프롬프트에 포함시켜 이런식으로 결과물을 받아올 수도 있긴하지만\n\n노트패드 작성시에 AI 기능이 있었다면 더 좋지 않을까 싶네요 아직 베타니까 기다려봅시다.\n\n---\n\n## **#7 프로젝트 5분만에 분석하는 법**\n\nCursor를 이용해 5분 만에 프로젝트 구조를 파악하는 방법을 알려드리겠습니다.\n\n> 1. Ctrl + L 을 눌러 Cursor 채팅 패널을 엽니다.\n>\n> [http://www.mermaidchart.com](http://www.mermaidchart.com/)\n\nhttps://kimyir.tistory.com/97\n\n[**Cursor로 5분만에 프로젝트 분석하기**\n프로젝트 5분만에 분석하는 법 Cursor를 이용해 5분 만에 프로젝트 구조를 파악하는 방법을 알려드리겠습니다. 1. Ctrl + L 을 눌러 Cursor 채팅 패널을 엽니다. 2. \"Normal chat\"에서 \"Long Co\nkimyir.tistory.com](https://kimyir.tistory.com/97)\n\n---\n\n이상 Cursor의 기본 사용 방법과 꿀팁을 정리해보았습니다.\n\nVSCode를 바탕으로 만들어서 그런지 접근하기 쉬웠고 쓰기도 편한 것 같습니다.\n\n물론 기능이 많은 만큼 IDE 속도가 느려진 것 같지만 능률을 위해서라면 그래도 쓸 것 같네요.\n\n내 코드가 혹시나 AI가 학습하지 않을까 걱정되신다면\n\nCursor Settings -> General -> Privacy mode 탭에 가셔서 enabled로 설정해주시면 됩니다.\n\n코드가 외부에 유출안되지만 AI 답변 품질이 떨어질 순 있습니다.\n\n**번외) 다른 유용한 AI 추천**\n\n터미널 AI 도우미\n\nhttps://github.com/Aider-AI/aider\n","category":"projects","date":"2024-03-20","tags":["Cursor","AI","VSCode"],"thumbnail":"/images/cursor.png"},{"id":"fds","title":"FDS 기획","description":"블록체인 기반 가상자산 거래의 이상 탐지 시스템 설계","content":"<h2>시스템 개요</h2>\n<p>가상자산 이상 거래 탐지 시스템(Virtual Asset FDS, VA-FDS)은 블록체인 네트워크에서 발생하는 비정상적인 거래 패턴을 실시간으로 감지하고 대응하는 시스템입니다.</p>\n<h3>주요 특징</h3>\n<ol>\n<li>\n<p><strong>블록체인 특화 데이터 수집</strong></p>\n<ul>\n<li>온체인 트랜잭션 데이터</li>\n<li>지갑 주소 행위 패턴</li>\n<li>스마트 컨트랙트 인터랙션</li>\n<li>DEX/CEX 거래 데이터</li>\n</ul>\n</li>\n<li>\n<p><strong>하이브리드 분석 방식</strong></p>\n<ul>\n<li>룰 기반 탐지 (Rule-based Detection)</li>\n<li>머신러닝 기반 이상 탐지</li>\n<li>온체인 데이터 분석</li>\n<li>크로스체인 추적</li>\n</ul>\n</li>\n</ol>\n<h2>핵심 기능</h2>\n<p><img src=\"/images/fds.jpeg\" alt=\"Profile Image 1\"></p>\n<h3>1. 실시간 트랜잭션 모니터링</h3>\n<ul>\n<li>대량 송금 패턴 감지</li>\n<li>이상 거래 금액 탐지</li>\n<li>의심스러운 지갑 주소 추적</li>\n<li>스마트 컨트랙트 취약점 분석</li>\n</ul>\n<h3>2. 크로스체인 추적 시스템</h3>\n<ul>\n<li>브리지 트랜잭션 모니터링</li>\n<li>체인 간 자금 흐름 추적</li>\n<li>크로스체인 세탁 패턴 감지</li>\n<li>브리지 해킹 위험 감지</li>\n</ul>\n<h3>3. AI 기반 패턴 분석</h3>\n<ul>\n<li>지도학습: RandomForest, XGBoost</li>\n<li>비지도학습: Isolation Forest</li>\n<li>딥러닝: LSTM, GNN</li>\n<li>앙상블 기법 적용</li>\n</ul>\n<h2>기술 스택</h2>\n<h3>Backend</h3>\n<ul>\n<li>Node.js/Python</li>\n<li>PostgreSQL (트랜잭션 데이터)</li>\n<li>Redis (실시간 캐싱)</li>\n<li>Kafka (스트림 처리)</li>\n</ul>\n<h3>Blockchain</h3>\n<ul>\n<li>Web3.js/Ethers.js</li>\n<li>The Graph (데이터 인덱싱)</li>\n<li>Chainlink (오라클)</li>\n</ul>\n<h3>AI/ML</h3>\n<ul>\n<li>TensorFlow/PyTorch</li>\n<li>scikit-learn</li>\n<li>NetworkX (그래프 분석)</li>\n</ul>\n<h2>시스템 아키텍처</h2>\n<pre><code class=\"language-plaintext\">[블록체인 네트워크]\n    │\n    ├─ [이더리움 노드] ─── [The Graph 인덱서]\n    ├─ [바이낸스 노드] ─── [체인 브릿지 모니터]\n    └─ [기타 체인 노드] ── [크로스체인 트래커]\n              │\n              ▼\n[데이터 수집 레이어]\n    │\n    ├─ [트랜잭션 콜렉터] ── (실시간 거래 데이터)\n    ├─ [컨트랙트 스캐너] ── (스마트 컨트랙트 호출)\n    └─ [이벤트 리스너] ──── (체인 이벤트 로그)\n              │\n              ▼\n[스트림 프로세싱]\n    │\n    ├─ [Kafka 프로듀서] ─── (실시간 데이터 스트림)\n    ├─ [Redis 캐시] ─────── (고속 데이터 처리)\n    └─ [데이터 파서] ────── (정형/비정형 데이터 변환)\n              │\n              ▼\n[분석 엔진]\n    │\n    ├─ [룰 기반 엔진] ────── (정적 규칙 검사)\n    │      └─ [임계값 체크] ─ (거래량/금액 분석)\n    │\n    ├─ [ML 엔진]\n    │      ├─ [지도학습 모델] ── (이상 패턴 분류)\n    │      ├─ [비지도학습 모델] ─ (이상치 탐지)\n    │      └─ [앙상블 모델] ──── (통합 예측)\n    │\n    └─ [그래프 분석기]\n           ├─ [주소 클러스터링] ── (연관 지갑 그룹화)\n           └─ [자금 흐름 추적] ─── (거래 경로 분석)\n              │\n              ▼\n[실시간 모니터링]\n    │\n    ├─ [알림 시스템]\n    │      ├─ [우선순위 분류기] ── (위험도 평가)\n    │      └─ [알림 디스패처] ─── (채널별 알림 발송)\n    │\n    └─ [대응 시스템]\n           ├─ [자동화 대응] ────── (거래 차단/제한)\n           ├─ [수동 검토] ─────── (분석가 확인)\n           └─ [보고서 생성] ───── (감사 추적)\n</code></pre>\n<h3>주요 컴포넌트 설명</h3>\n<ol>\n<li>\n<p><strong>블록체인 네트워크 레이어</strong></p>\n<ul>\n<li>다중 체인 노드 운영</li>\n<li>실시간 블록 데이터 수집</li>\n<li>크로스체인 브릿지 모니터링</li>\n</ul>\n</li>\n<li>\n<p><strong>데이터 수집 레이어</strong></p>\n<ul>\n<li>트랜잭션 데이터 실시간 수집</li>\n<li>스마트 컨트랙트 인터랙션 분석</li>\n<li>체인 이벤트 로그 추적</li>\n</ul>\n</li>\n<li>\n<p><strong>스트림 프로세싱 레이어</strong></p>\n<ul>\n<li>대용량 실시간 데이터 처리</li>\n<li>인메모리 캐싱</li>\n<li>데이터 정규화 및 변환</li>\n</ul>\n</li>\n<li>\n<p><strong>분석 엔진 레이어</strong></p>\n<ul>\n<li>다중 분석 모델 운영</li>\n<li>실시간 패턴 매칭</li>\n<li>머신러닝 기반 예측</li>\n</ul>\n</li>\n<li>\n<p><strong>모니터링 및 대응 레이어</strong></p>\n<ul>\n<li>실시간 위험 평가</li>\n<li>자동화된 대응 체계</li>\n<li>감사 추적 시스템</li>\n</ul>\n</li>\n</ol>\n<h2>구현 계획</h2>\n<h3>Phase 1: 기본 인프라 구축</h3>\n<ul>\n<li>데이터 수집 파이프라인 구축</li>\n<li>기본 룰 기반 탐지 시스템 구현</li>\n<li>실시간 모니터링 대시보드 개발</li>\n</ul>\n<h3>Phase 2: AI 모델 개발</h3>\n<ul>\n<li>지도학습 모델 훈련</li>\n<li>비지도학습 모델 구현</li>\n<li>앙상블 시스템 구축</li>\n</ul>\n<h3>Phase 3: 크로스체인 확장</h3>\n<ul>\n<li>멀티체인 데이터 수집</li>\n<li>크로스체인 추적 시스템</li>\n<li>통합 대시보드 개발</li>\n</ul>\n<h2>기대 효과</h2>\n<ol>\n<li>\n<p><strong>보안성 강화</strong></p>\n<ul>\n<li>해킹 시도 조기 감지</li>\n<li>자금 세탁 방지</li>\n<li>사기 거래 예방</li>\n</ul>\n</li>\n<li>\n<p><strong>운영 효율성</strong></p>\n<ul>\n<li>자동화된 모니터링</li>\n<li>실시간 대응 체계</li>\n<li>리스크 관리 강화</li>\n</ul>\n</li>\n<li>\n<p><strong>사용자 신뢰도</strong></p>\n<ul>\n<li>안전한 거래 환경</li>\n<li>투명한 모니터링</li>\n<li>신속한 이상 거래 대응</li>\n</ul>\n</li>\n</ol>\n<h2>향후 발전 방향</h2>\n<ol>\n<li>\n<p><strong>탈중앙화 FDS</strong></p>\n<ul>\n<li>DAO 기반 거버넌스</li>\n<li>탈중앙화 신고 시스템</li>\n<li>커뮤니티 기반 검증</li>\n</ul>\n</li>\n<li>\n<p><strong>AI 고도화</strong></p>\n<ul>\n<li>제로샷 러닝 도입</li>\n<li>강화학습 모델 적용</li>\n<li>연합학습 시스템</li>\n</ul>\n</li>\n<li>\n<p><strong>생태계 확장</strong></p>\n<ul>\n<li>DeFi 프로토콜 연동</li>\n<li>CEX 협력 체계</li>\n<li>규제기관 협력</li>\n</ul>\n</li>\n</ol>\n","plainContent":"\n## 시스템 개요\n\n가상자산 이상 거래 탐지 시스템(Virtual Asset FDS, VA-FDS)은 블록체인 네트워크에서 발생하는 비정상적인 거래 패턴을 실시간으로 감지하고 대응하는 시스템입니다.\n\n### 주요 특징\n\n1. **블록체인 특화 데이터 수집**\n\n   - 온체인 트랜잭션 데이터\n   - 지갑 주소 행위 패턴\n   - 스마트 컨트랙트 인터랙션\n   - DEX/CEX 거래 데이터\n\n2. **하이브리드 분석 방식**\n   - 룰 기반 탐지 (Rule-based Detection)\n   - 머신러닝 기반 이상 탐지\n   - 온체인 데이터 분석\n   - 크로스체인 추적\n\n## 핵심 기능\n\n![Profile Image 1](/images/fds.jpeg)\n\n### 1. 실시간 트랜잭션 모니터링\n\n- 대량 송금 패턴 감지\n- 이상 거래 금액 탐지\n- 의심스러운 지갑 주소 추적\n- 스마트 컨트랙트 취약점 분석\n\n### 2. 크로스체인 추적 시스템\n\n- 브리지 트랜잭션 모니터링\n- 체인 간 자금 흐름 추적\n- 크로스체인 세탁 패턴 감지\n- 브리지 해킹 위험 감지\n\n### 3. AI 기반 패턴 분석\n\n- 지도학습: RandomForest, XGBoost\n- 비지도학습: Isolation Forest\n- 딥러닝: LSTM, GNN\n- 앙상블 기법 적용\n\n## 기술 스택\n\n### Backend\n\n- Node.js/Python\n- PostgreSQL (트랜잭션 데이터)\n- Redis (실시간 캐싱)\n- Kafka (스트림 처리)\n\n### Blockchain\n\n- Web3.js/Ethers.js\n- The Graph (데이터 인덱싱)\n- Chainlink (오라클)\n\n### AI/ML\n\n- TensorFlow/PyTorch\n- scikit-learn\n- NetworkX (그래프 분석)\n\n## 시스템 아키텍처\n\n```plaintext\n[블록체인 네트워크]\n    │\n    ├─ [이더리움 노드] ─── [The Graph 인덱서]\n    ├─ [바이낸스 노드] ─── [체인 브릿지 모니터]\n    └─ [기타 체인 노드] ── [크로스체인 트래커]\n              │\n              ▼\n[데이터 수집 레이어]\n    │\n    ├─ [트랜잭션 콜렉터] ── (실시간 거래 데이터)\n    ├─ [컨트랙트 스캐너] ── (스마트 컨트랙트 호출)\n    └─ [이벤트 리스너] ──── (체인 이벤트 로그)\n              │\n              ▼\n[스트림 프로세싱]\n    │\n    ├─ [Kafka 프로듀서] ─── (실시간 데이터 스트림)\n    ├─ [Redis 캐시] ─────── (고속 데이터 처리)\n    └─ [데이터 파서] ────── (정형/비정형 데이터 변환)\n              │\n              ▼\n[분석 엔진]\n    │\n    ├─ [룰 기반 엔진] ────── (정적 규칙 검사)\n    │      └─ [임계값 체크] ─ (거래량/금액 분석)\n    │\n    ├─ [ML 엔진]\n    │      ├─ [지도학습 모델] ── (이상 패턴 분류)\n    │      ├─ [비지도학습 모델] ─ (이상치 탐지)\n    │      └─ [앙상블 모델] ──── (통합 예측)\n    │\n    └─ [그래프 분석기]\n           ├─ [주소 클러스터링] ── (연관 지갑 그룹화)\n           └─ [자금 흐름 추적] ─── (거래 경로 분석)\n              │\n              ▼\n[실시간 모니터링]\n    │\n    ├─ [알림 시스템]\n    │      ├─ [우선순위 분류기] ── (위험도 평가)\n    │      └─ [알림 디스패처] ─── (채널별 알림 발송)\n    │\n    └─ [대응 시스템]\n           ├─ [자동화 대응] ────── (거래 차단/제한)\n           ├─ [수동 검토] ─────── (분석가 확인)\n           └─ [보고서 생성] ───── (감사 추적)\n```\n\n### 주요 컴포넌트 설명\n\n1. **블록체인 네트워크 레이어**\n\n   - 다중 체인 노드 운영\n   - 실시간 블록 데이터 수집\n   - 크로스체인 브릿지 모니터링\n\n2. **데이터 수집 레이어**\n\n   - 트랜잭션 데이터 실시간 수집\n   - 스마트 컨트랙트 인터랙션 분석\n   - 체인 이벤트 로그 추적\n\n3. **스트림 프로세싱 레이어**\n\n   - 대용량 실시간 데이터 처리\n   - 인메모리 캐싱\n   - 데이터 정규화 및 변환\n\n4. **분석 엔진 레이어**\n\n   - 다중 분석 모델 운영\n   - 실시간 패턴 매칭\n   - 머신러닝 기반 예측\n\n5. **모니터링 및 대응 레이어**\n   - 실시간 위험 평가\n   - 자동화된 대응 체계\n   - 감사 추적 시스템\n\n## 구현 계획\n\n### Phase 1: 기본 인프라 구축\n\n- 데이터 수집 파이프라인 구축\n- 기본 룰 기반 탐지 시스템 구현\n- 실시간 모니터링 대시보드 개발\n\n### Phase 2: AI 모델 개발\n\n- 지도학습 모델 훈련\n- 비지도학습 모델 구현\n- 앙상블 시스템 구축\n\n### Phase 3: 크로스체인 확장\n\n- 멀티체인 데이터 수집\n- 크로스체인 추적 시스템\n- 통합 대시보드 개발\n\n## 기대 효과\n\n1. **보안성 강화**\n\n   - 해킹 시도 조기 감지\n   - 자금 세탁 방지\n   - 사기 거래 예방\n\n2. **운영 효율성**\n\n   - 자동화된 모니터링\n   - 실시간 대응 체계\n   - 리스크 관리 강화\n\n3. **사용자 신뢰도**\n   - 안전한 거래 환경\n   - 투명한 모니터링\n   - 신속한 이상 거래 대응\n\n## 향후 발전 방향\n\n1. **탈중앙화 FDS**\n\n   - DAO 기반 거버넌스\n   - 탈중앙화 신고 시스템\n   - 커뮤니티 기반 검증\n\n2. **AI 고도화**\n\n   - 제로샷 러닝 도입\n   - 강화학습 모델 적용\n   - 연합학습 시스템\n\n3. **생태계 확장**\n   - DeFi 프로토콜 연동\n   - CEX 협력 체계\n   - 규제기관 협력\n","category":"projects","date":"2024-03-20","tags":["Blockchain","FDS","Security","AI"],"thumbnail":"/images/solidity.webp"},{"id":"manbok","title":"공인중개 웹사이트","description":"공인중개 웹사이트 개발","content":"<p><img src=\"/images/manbok/manbok.png\" alt=\"2\"></p>\n<h2>프로젝트 개요</h2>\n<p>토지, 공장, 창고의 매매/임대를 전문으로 하는 공인중개사무소와 원룸, 상가의 매매/임대를 전문으로 하는 공인중개사무소의 통합 웹 플랫폼을 구축합니다. 빅데이터 기반의 부동산 입지 분석과 AI 기반 매물 추천 시스템을 통해 매수인, 매도인, 임대인, 임차인에게 최적화된 부동산 솔루션을 제공하는 것이 목표입니다.</p>\n<h3>주요 기능</h3>\n<ol>\n<li>\n<p><strong>스마트 매물 관리 시스템</strong></p>\n<ul>\n<li>실시간 매물 등록/수정/삭제</li>\n<li>AI 기반 매물 가격 산정</li>\n<li>매물 상태 자동 업데이트</li>\n<li>고도화된 검색 및 필터링</li>\n<li>VR/AR 매물 투어</li>\n<li>실시간 시세 정보 연동</li>\n</ul>\n</li>\n<li>\n<p><strong>빅데이터 기반 입지 분석 시스템</strong></p>\n<ul>\n<li>GIS 기반 위치 분석</li>\n<li>교통/물류 접근성 분석</li>\n<li>용도지역/구역 법률 검토</li>\n<li>실시간 경제 지표 연동</li>\n<li>환경영향 평가</li>\n<li>주변 인프라 현황 분석</li>\n<li>수요/공급 예측 모델링</li>\n</ul>\n</li>\n<li>\n<p><strong>통합 고객 관리 시스템 (CRM)</strong></p>\n<ul>\n<li>고객 데이터 통합 관리</li>\n<li>AI 기반 고객 매칭</li>\n<li>상담 이력 자동 기록</li>\n<li>관심 매물 패턴 분석</li>\n<li>계약 진행 자동화</li>\n<li>고객 피드백 관리</li>\n</ul>\n</li>\n<li>\n<p><strong>지능형 컨텐츠 관리 시스템</strong></p>\n<ul>\n<li>AI 기반 컨텐츠 생성</li>\n<li>자동 SEO 최적화</li>\n<li>소셜 미디어 연동</li>\n<li>실시간 부동산 뉴스 피드</li>\n<li>맞춤형 뉴스레터 발송</li>\n<li>컨텐츠 성과 분석</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"/images/manbok/manbok.gif\" alt=\"3\"></p>\n<h3>기술 스택</h3>\n<ul>\n<li>Frontend: Next.js 14, TypeScript, React Query, Recoil</li>\n<li>Backend: NestJS, GraphQL, TypeORM</li>\n<li>Database: PostgreSQL, Redis, Elasticsearch</li>\n<li>AI/ML: TensorFlow, scikit-learn</li>\n<li>Infrastructure: AWS (ECS, RDS, S3, CloudFront)</li>\n<li>DevOps: Docker, Kubernetes, Jenkins, Prometheus</li>\n<li>Analytics: Google Analytics 4, Amplitude</li>\n</ul>\n<h3>개발 로드맵</h3>\n<ol>\n<li>\n<p>기획 및 설계 (3주)</p>\n<ul>\n<li>요구사항 상세 분석</li>\n<li>UI/UX 프로토타이핑</li>\n<li>데이터 모델링</li>\n<li>시스템 아키텍처 설계</li>\n<li>API 설계 및 문서화</li>\n</ul>\n</li>\n<li>\n<p>프론트엔드 개발 (6주)</p>\n<ul>\n<li>반응형 메인 페이지 구현</li>\n<li>실시간 매물 관리 시스템</li>\n<li>대시보드 및 분석 도구</li>\n<li>VR/AR 매물 뷰어</li>\n<li>성능 최적화</li>\n</ul>\n</li>\n<li>\n<p>백엔드 개발 (6주)</p>\n<ul>\n<li>MSA 기반 API 서버</li>\n<li>실시간 데이터 동기화</li>\n<li>AI 모델 통합</li>\n<li>보안 시스템 구축</li>\n<li>결제 시스템 연동</li>\n</ul>\n</li>\n<li>\n<p>품질 관리 및 배포 (3주)</p>\n<ul>\n<li>자동화된 테스트 구축</li>\n<li>성능 모니터링 시스템</li>\n<li>CI/CD 파이프라인 구축</li>\n<li>무중단 배포 시스템</li>\n<li>장애 대응 체계 수립</li>\n</ul>\n</li>\n</ol>\n<h3>기대 효과</h3>\n<ol>\n<li>데이터 기반 의사결정 지원</li>\n<li>업무 효율성 300% 향상</li>\n<li>고객 만족도 증대</li>\n<li>매출 증대 효과</li>\n<li>시장 경쟁력 강화</li>\n<li>디지털 전환 가속화</li>\n</ol>\n","plainContent":"\n![2](/images/manbok/manbok.png)\n\n## 프로젝트 개요\n\n토지, 공장, 창고의 매매/임대를 전문으로 하는 공인중개사무소와 원룸, 상가의 매매/임대를 전문으로 하는 공인중개사무소의 통합 웹 플랫폼을 구축합니다. 빅데이터 기반의 부동산 입지 분석과 AI 기반 매물 추천 시스템을 통해 매수인, 매도인, 임대인, 임차인에게 최적화된 부동산 솔루션을 제공하는 것이 목표입니다.\n\n### 주요 기능\n\n1. **스마트 매물 관리 시스템**\n\n   - 실시간 매물 등록/수정/삭제\n   - AI 기반 매물 가격 산정\n   - 매물 상태 자동 업데이트\n   - 고도화된 검색 및 필터링\n   - VR/AR 매물 투어\n   - 실시간 시세 정보 연동\n\n2. **빅데이터 기반 입지 분석 시스템**\n\n   - GIS 기반 위치 분석\n   - 교통/물류 접근성 분석\n   - 용도지역/구역 법률 검토\n   - 실시간 경제 지표 연동\n   - 환경영향 평가\n   - 주변 인프라 현황 분석\n   - 수요/공급 예측 모델링\n\n3. **통합 고객 관리 시스템 (CRM)**\n\n   - 고객 데이터 통합 관리\n   - AI 기반 고객 매칭\n   - 상담 이력 자동 기록\n   - 관심 매물 패턴 분석\n   - 계약 진행 자동화\n   - 고객 피드백 관리\n\n4. **지능형 컨텐츠 관리 시스템**\n   - AI 기반 컨텐츠 생성\n   - 자동 SEO 최적화\n   - 소셜 미디어 연동\n   - 실시간 부동산 뉴스 피드\n   - 맞춤형 뉴스레터 발송\n   - 컨텐츠 성과 분석\n\n![3](/images/manbok/manbok.gif)\n\n### 기술 스택\n\n- Frontend: Next.js 14, TypeScript, React Query, Recoil\n- Backend: NestJS, GraphQL, TypeORM\n- Database: PostgreSQL, Redis, Elasticsearch\n- AI/ML: TensorFlow, scikit-learn\n- Infrastructure: AWS (ECS, RDS, S3, CloudFront)\n- DevOps: Docker, Kubernetes, Jenkins, Prometheus\n- Analytics: Google Analytics 4, Amplitude\n\n### 개발 로드맵\n\n1. 기획 및 설계 (3주)\n\n   - 요구사항 상세 분석\n   - UI/UX 프로토타이핑\n   - 데이터 모델링\n   - 시스템 아키텍처 설계\n   - API 설계 및 문서화\n\n2. 프론트엔드 개발 (6주)\n\n   - 반응형 메인 페이지 구현\n   - 실시간 매물 관리 시스템\n   - 대시보드 및 분석 도구\n   - VR/AR 매물 뷰어\n   - 성능 최적화\n\n3. 백엔드 개발 (6주)\n\n   - MSA 기반 API 서버\n   - 실시간 데이터 동기화\n   - AI 모델 통합\n   - 보안 시스템 구축\n   - 결제 시스템 연동\n\n4. 품질 관리 및 배포 (3주)\n   - 자동화된 테스트 구축\n   - 성능 모니터링 시스템\n   - CI/CD 파이프라인 구축\n   - 무중단 배포 시스템\n   - 장애 대응 체계 수립\n\n### 기대 효과\n\n1. 데이터 기반 의사결정 지원\n2. 업무 효율성 300% 향상\n3. 고객 만족도 증대\n4. 매출 증대 효과\n5. 시장 경쟁력 강화\n6. 디지털 전환 가속화\n","category":"projects","date":"2024-03-20","tags":["React"," JavaScript"],"thumbnail":"/images/manbok/manbok.gif"},{"id":"mobyn","title":"전자고지 시스템 개발","description":"카카오/네이버/KT 전자문서 발송 및 통계 시스템","content":"<h2>시스템 개요</h2>\n<p>전자고지 시스템은 기업이나 기관에서 발행하는 각종 고지서를 카카오, 네이버, KT 등의 플랫폼을 통해 전자문서로 발송하고 관리하는 통합 솔루션입니다.</p>\n<h3>주요 기능</h3>\n<ol>\n<li><strong>전자고지서 발송 관리</strong>\n<ul>\n<li>대상자 그룹 관리</li>\n<li>발송 이력 추적</li>\n<li>멀티 플랫폼 발송 설정</li>\n<li>발송 상태 모니터링</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"/images/mobyn/mobyn_document_payment.gif\" alt=\"3\">\n(결제 정보 관리 및 처리)</p>\n<ol start=\"2\">\n<li><strong>결제 시스템 연동</strong>\n<ul>\n<li>NICEpay 결제 모듈 통합</li>\n<li>실시간 결제 상태 확인</li>\n<li>결제 이력 관리</li>\n<li>환불 프로세스 지원</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"/images/mobyn/mobyn_stats_1.gif\" alt=\"5\">\n(일별/월별 발송량 통계 분석)</p>\n<p><img src=\"/images/mobyn/mobyn_stats_2.gif\" alt=\"6\">\n(플랫폼별 발송 성공률 분석)</p>\n<p><img src=\"/images/mobyn/mobyn_stats_3.gif\" alt=\"7\">\n(결제 전환율 및 매출 분석)</p>\n<p><img src=\"/images/mobyn/mobyn_stats_4.gif\" alt=\"8\">\n(기간별 상세 통계 리포트)</p>\n<ol start=\"3\">\n<li><strong>통계 대시보드</strong></li>\n</ol>\n<ul>\n<li>발송 현황 분석</li>\n<li>플랫폼별 성공률 추적</li>\n<li>결제 전환율 모니터링</li>\n<li>기간별 통계 리포트</li>\n</ul>\n<p><img src=\"/images/mobyn/mobyn_document_management.gif\" alt=\"2\">\n(문서 템플릿 관리 및 편집)</p>\n<ol start=\"4\">\n<li><strong>발송 관리 시스템</strong>\n<ul>\n<li>대상자 그룹 관리</li>\n<li>발송 이력 추적</li>\n<li>멀티 플랫폼 발송 설정</li>\n<li>발송 상태 모니터링</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"/images/mobyn/mobyn_status.gif\" alt=\"9\">\n(실시간 발송 상태 모니터링)</p>\n<ol start=\"5\">\n<li><strong>발송 제목 및 내용 관리</strong>\n<ul>\n<li>발송 제목 및 내용 관리</li>\n<li>대상자 그룹 관리</li>\n<li>발송 이력 추적</li>\n<li>멀티 플랫폼 발송 설정</li>\n<li>발송 상태 모니터링</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"/images/mobyn/mobyn_subject.gif\" alt=\"10\">\n(발송 제목 및 내용 관리)</p>\n<ol start=\"6\">\n<li><strong>발송 대상자 관리</strong>\n<ul>\n<li>대상자 그룹 관리</li>\n<li>발송 이력 추적</li>\n<li>멀티 플랫폼 발송 설정</li>\n<li>발송 상태 모니터링</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"/images/mobyn/mobyn_send.gif\" alt=\"4\">\n(대량 발송 프로세스 실행)</p>\n<ol start=\"7\">\n<li><strong>발송 예약 관리</strong>\n<ul>\n<li>발송 예약 관리</li>\n<li>발송 이력 추적</li>\n<li>멀티 플랫폼 발송 설정</li>\n<li>발송 상태 모니터링</li>\n</ul>\n</li>\n</ol>\n","plainContent":"\n## 시스템 개요\n\n전자고지 시스템은 기업이나 기관에서 발행하는 각종 고지서를 카카오, 네이버, KT 등의 플랫폼을 통해 전자문서로 발송하고 관리하는 통합 솔루션입니다.\n\n### 주요 기능\n\n1. **전자고지서 발송 관리**\n   - 대상자 그룹 관리\n   - 발송 이력 추적\n   - 멀티 플랫폼 발송 설정\n   - 발송 상태 모니터링\n\n![3](/images/mobyn/mobyn_document_payment.gif)\n(결제 정보 관리 및 처리)\n\n2. **결제 시스템 연동**\n   - NICEpay 결제 모듈 통합\n   - 실시간 결제 상태 확인\n   - 결제 이력 관리\n   - 환불 프로세스 지원\n\n![5](/images/mobyn/mobyn_stats_1.gif)\n(일별/월별 발송량 통계 분석)\n\n![6](/images/mobyn/mobyn_stats_2.gif)\n(플랫폼별 발송 성공률 분석)\n\n![7](/images/mobyn/mobyn_stats_3.gif)\n(결제 전환율 및 매출 분석)\n\n![8](/images/mobyn/mobyn_stats_4.gif)\n(기간별 상세 통계 리포트)\n\n3. **통계 대시보드**\n\n- 발송 현황 분석\n- 플랫폼별 성공률 추적\n- 결제 전환율 모니터링\n- 기간별 통계 리포트\n\n![2](/images/mobyn/mobyn_document_management.gif)\n(문서 템플릿 관리 및 편집)\n\n4. **발송 관리 시스템**\n   - 대상자 그룹 관리\n   - 발송 이력 추적\n   - 멀티 플랫폼 발송 설정\n   - 발송 상태 모니터링\n\n![9](/images/mobyn/mobyn_status.gif)\n(실시간 발송 상태 모니터링)\n\n5. **발송 제목 및 내용 관리**\n   - 발송 제목 및 내용 관리\n   - 대상자 그룹 관리\n   - 발송 이력 추적\n   - 멀티 플랫폼 발송 설정\n   - 발송 상태 모니터링\n\n![10](/images/mobyn/mobyn_subject.gif)\n(발송 제목 및 내용 관리)\n\n6. **발송 대상자 관리**\n   - 대상자 그룹 관리\n   - 발송 이력 추적\n   - 멀티 플랫폼 발송 설정\n   - 발송 상태 모니터링\n\n![4](/images/mobyn/mobyn_send.gif)\n(대량 발송 프로세스 실행)\n\n7. **발송 예약 관리**\n   - 발송 예약 관리\n   - 발송 이력 추적\n   - 멀티 플랫폼 발송 설정\n   - 발송 상태 모니터링\n","category":"projects","date":"2024-03-20","tags":["React","NicePay","TypeScript","React Hook Form"],"thumbnail":"/images/mobyn/mobyn_dashboard.gif"}]